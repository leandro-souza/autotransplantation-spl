
#include "InterfaceHeader.h"
struct exarg {
    char_u *arg;
    char_u *nextcmd;
    char_u *cmd;
    char_u **cmdlinep;
    cmdidx_T cmdidx;
    long  argt;
    int skip;
    int forceit;
    int addr_count;
    linenr_T line1;
    linenr_T line2;
    int addr_type;
    int flags;
    char_u *do_ecmd_cmd;
    linenr_T do_ecmd_lnum;
    int append;
    int usefilter;
    int amount;
    int regname;
    int force_bin;
    int read_edit;
    int force_ff;
    int useridx;
    char_u *errmsg;
    char_u * (*getline) (int, void *, int);
    void *cookie;
    struct condstack *cstack;
};
struct lval_S {
    char_u *ll_name;
    char_u *ll_exp_name;
    typval_T *ll_tv;
    listitem_T *ll_li;
    list_T *ll_list;
    int ll_range;
    long  ll_n1;
    long  ll_n2;
    int ll_empty2;
    dict_T *ll_dict;
    dictitem_T *ll_di;
    char_u *ll_newkey;
};
struct timer_S {
    long  tr_id;
    timer_T *tr_next;
    timer_T *tr_prev;
    proftime_T tr_due;
    char tr_firing;
    char tr_paused;
    int tr_repeat;
    long  tr_interval;
    char_u *tr_callback;
    partial_T *tr_partial;
    int tr_emsg_count;
};
struct js_reader {
    char_u *js_buf;
    char_u *js_end;
    int js_used;
    int (*js_fill) (struct js_reader *);
    void *js_cookie;
    int js_cookie_arg;
};
struct cmdarg_S {
    oparg_T *oap;
    int prechar;
    int cmdchar;
    int nchar;
    int extra_char;
    long  opcount;
    long  count0;
    long  count1;
    int arg;
    int retval;
    char_u *searchbuf;
};
struct oparg_S {
    int op_type;
    int regname;
    int motion_type;
    int motion_force;
    int use_reg_one;
    int inclusive;
    int end_adjusted;
    pos_T start;
    pos_T end;
    pos_T cursor_start;
    long  line_count;
    int empty;
    int is_VIsual;
    int block_mode;
    colnr_T start_vcol;
    colnr_T end_vcol;
    long  prev_opcount;
    long  prev_count0;
};
struct tabpage_S {
    tabpage_T *tp_next;
    frame_T *tp_topframe;
    win_T *tp_curwin;
    win_T *tp_prevwin;
    win_T *tp_firstwin;
    win_T *tp_lastwin;
    long  tp_old_Rows;
    long  tp_old_Columns;
    long  tp_ch_used;
    int tp_prev_which_scrollbars [3];
    diff_T *tp_first_diff;
    buf_T * (tp_diffbuf [DB_COUNT]);
    int tp_diff_invalid;
    frame_T * (tp_snapshot [SNAP_COUNT]);
    dictitem_T tp_winvar;
    dict_T *tp_vars;
};
struct list_stack_S {
    list_T *list;
    struct list_stack_S *prev;
};
struct ht_stack_S {
    hashtab_T *ht;
    struct ht_stack_S *prev;
};
struct channel_S {
    channel_T *ch_next;
    channel_T *ch_prev;
    int ch_id;
    int ch_last_msg_id;
    chanpart_T ch_part [PART_COUNT];
    int ch_write_text_mode;
    char *ch_hostname;
    int ch_port;
    int ch_to_be_closed;
    int ch_to_be_freed;
    int ch_error;
    void (*ch_nb_close_cb) (void);
    char_u *ch_callback;
    partial_T *ch_partial;
    char_u *ch_close_cb;
    partial_T *ch_close_partial;
    int ch_drop_never;
    int ch_keep_open;
    job_T *ch_job;
    int ch_job_killed;
    int ch_refcount;
    int ch_copyID;
};
struct cbq_S {
    char_u *cq_callback;
    partial_T *cq_partial;
    int cq_seq_nr;
    cbq_T *cq_next;
    cbq_T *cq_prev;
};
struct jsonq_S {
    typval_T *jq_value;
    jsonq_T *jq_next;
    jsonq_T *jq_prev;
    int jq_no_callback;
};
struct writeq_S {
    garray_T wq_ga;
    writeq_T *wq_next;
    writeq_T *wq_prev;
};
struct readq_S {
    char_u *rq_buffer;
    long_u rq_buflen;
    readq_T *rq_next;
    readq_T *rq_prev;
};
struct partial_S {
    int pt_refcount;
    char_u *pt_name;
    ufunc_T *pt_func;
    int pt_auto;
    int pt_argc;
    typval_T *pt_argv;
    dict_T *pt_dict;
};
struct funccall_S {
    ufunc_T *func;
    int linenr;
    int returned;
    struct {
        dictitem_T var;
        char_u room [VAR_SHORT_LEN];
    } fixvar [FIXVAR_CNT];
    dict_T l_vars;
    dictitem_T l_vars_var;
    dict_T l_avars;
    dictitem_T l_avars_var;
    list_T l_varlist;
    listitem_T l_listitems [MAX_FUNC_ARGS];
    typval_T *rettv;
    linenr_T breakpoint;
    int dbg_tick;
    int level;
    proftime_T prof_child;
    funccall_T *caller;
    int fc_refcount;
    int fc_copyID;
    garray_T fc_funcs;
};
struct listwatch_S {
    listitem_T *lw_item;
    listwatch_T *lw_next;
};
struct listitem_S {
    listitem_T *li_next;
    listitem_T *li_prev;
    typval_T li_tv;
};
struct hashitem_S {
    long_u hi_hash;
    char_u *hi_key;
};
struct condstack {
    short  cs_flags [CSTACK_LEN];
    char cs_pending [CSTACK_LEN];
    union {
        void *csp_rv [CSTACK_LEN];
        void *csp_ex [CSTACK_LEN];
    } cs_pend;
    void *cs_forinfo [CSTACK_LEN];
    int cs_line [CSTACK_LEN];
    int cs_idx;
    int cs_looplevel;
    int cs_trylevel;
    eslist_T *cs_emsg_silent_list;
    char cs_lflags;
};
struct eslist_elem {
    int saved_emsg_silent;
    eslist_T *next;
};
struct argentry {
    char_u *ae_fname;
    int ae_fnum;
};
struct info_pointer {
    blocknr_T ip_bnum;
    linenr_T ip_low;
    linenr_T ip_high;
    int ip_index;
};
struct memfile {
    char_u *mf_fname;
    char_u *mf_ffname;
    int mf_fd;
    bhdr_T *mf_free_first;
    bhdr_T *mf_used_first;
    bhdr_T *mf_used_last;
    unsigned  mf_used_count;
    unsigned  mf_used_count_max;
    mf_hashtab_T mf_hash;
    mf_hashtab_T mf_trans;
    blocknr_T mf_blocknr_max;
    blocknr_T mf_blocknr_min;
    blocknr_T mf_neg_count;
    blocknr_T mf_infile_count;
    unsigned  mf_page_size;
    int mf_dirty;
    buf_T *mf_buffer;
    char_u mf_seed [MF_SEED_LEN];
    char_u *mf_old_key;
    int mf_old_cm;
    char_u mf_old_seed [MF_SEED_LEN];
};
struct expand {
    int xp_context;
    char_u *xp_pattern;
    int xp_pattern_len;
    char_u *xp_arg;
    int xp_scriptID;
    int xp_backslash;
    int xp_shell;
    int xp_numfiles;
    char_u **xp_files;
    char_u *xp_line;
    int xp_col;
};
struct nr_trans {
    mf_hashitem_T nt_hashitem;

    #define nt_old_bnum nt_hashitem.mhi_key	/* old, negative, number */
    blocknr_T nt_new_bnum;
};
struct block_hdr {
    mf_hashitem_T bh_hashitem;

    #define bh_bnum bh_hashitem.mhi_key /* block number, part of bh_hashitem */
    bhdr_T *bh_next;
    bhdr_T *bh_prev;
    char_u *bh_data;
    int bh_page_count;

    #define BH_DIRTY    1

    #define BH_LOCKED   2
    char bh_flags;
};
struct mf_hashitem_S {
    mf_hashitem_T *mhi_next;
    mf_hashitem_T *mhi_prev;
    blocknr_T mhi_key;
};
struct m_info {
    short_u m_size;
    minfo_T *m_next;
};
struct u_entry {
    u_entry_T *ue_next;
    linenr_T ue_top;
    linenr_T ue_bot;
    linenr_T ue_lcount;
    char_u **ue_array;
    long  ue_size;
};
struct foldinfo {
    int fi_level;
    int fi_lnum;
    int fi_low_level;
};
struct filemark {
    pos_T mark;
    int fnum;
};
struct object_constant {
    char *name;
    PyObject *valObject;
};
struct numeric_constant {
    char *name;
    int val;
};
struct pylinkedlist_S {
    struct pylinkedlist_S *pll_next;
    struct pylinkedlist_S *pll_prev;
    PyObject *pll_obj;
};
struct spelltab_S {
    char_u st_isw [256];
    char_u st_isu [256];
    char_u st_fold [256];
    char_u st_upper [256];
};
struct langp_S {
    slang_T *lp_slang;
    slang_T *lp_sallang;
    slang_T *lp_replang;
    int lp_region;
};
struct salitem_S {
    char_u *sm_lead;
    int sm_leadlen;
    char_u *sm_oneof;
    char_u *sm_rules;
    char_u *sm_to;
};
struct fromto_S {
    char_u *ft_from;
    char_u *ft_to;
};
struct slang_S {
    slang_T *sl_next;
    char_u *sl_name;
    char_u *sl_fname;
    int sl_add;
    char_u *sl_fbyts;
    idx_T *sl_fidxs;
    char_u *sl_kbyts;
    idx_T *sl_kidxs;
    char_u *sl_pbyts;
    idx_T *sl_pidxs;
    char_u *sl_info;
    char_u sl_regions [MAXREGIONS * 2 + 1];
    char_u *sl_midword;
    hashtab_T sl_wordcount;
    int sl_compmax;
    int sl_compminlen;
    int sl_compsylmax;
    int sl_compoptions;
    garray_T sl_comppat;
    regprog_T *sl_compprog;
    char_u *sl_comprules;
    char_u *sl_compstartflags;
    char_u *sl_compallflags;
    char_u sl_nobreak;
    char_u *sl_syllable;
    garray_T sl_syl_items;
    int sl_prefixcnt;
    regprog_T **sl_prefprog;
    garray_T sl_rep;
    short  sl_rep_first [256];
    garray_T sl_sal;
    salfirst_T sl_sal_first [256];
    int sl_followup;
    int sl_collapse;
    int sl_rem_accents;
    int sl_sofo;
    garray_T sl_repsal;
    short  sl_repsal_first [256];
    int sl_nosplitsugs;
    int sl_nocompoundsugs;
    time_t sl_sugtime;
    char_u *sl_sbyts;
    idx_T *sl_sidxs;
    buf_T *sl_sugbuf;
    int sl_sugloaded;
    int sl_has_map;
    char_u sl_map_array [256];
    hashtab_T sl_sounddone;
};
struct prt_dsc_comment_S {
    char *string;
    int len;
    int type;
};
struct prt_ps_resource_S {
    char_u name [64];
    char_u filename [MAXPATHL + 1];
    int type;
    char_u title [256];
    char_u version [256];
};
struct prt_ps_charset_S {
    char *charset;
    char *cmap_charset;
    int has_charset;
};
struct prt_ps_encoding_S {
    char *encoding;
    char *cmap_encoding;
    int needs_charset;
};
struct prt_ps_font_S {
    int wx;
    int uline_offset;
    int uline_width;
    int bbox_min_y;
    int bbox_max_y;
    char * (ps_fontname [4]);
};
struct tag_pointers {
    char_u *tagname;
    char_u *tagname_end;
    char_u *fname;
    char_u *fname_end;
    char_u *command;
    char_u *command_end;
    char_u *tag_fname;
    int is_etag;
    char_u *tagkind;
    char_u *tagkind_end;
};
struct spellinfo_S {
    wordnode_T *si_foldroot;
    long  si_foldwcount;
    wordnode_T *si_keeproot;
    long  si_keepwcount;
    wordnode_T *si_prefroot;
    long  si_sugtree;
    sblock_T *si_blocks;
    long  si_blocks_cnt;
    int si_did_emsg;
    long  si_compress_cnt;
    wordnode_T *si_first_free;
    long  si_free_count;
    buf_T *si_spellbuf;
    int si_ascii;
    int si_add;
    int si_clear_chartab;
    int si_region;
    vimconv_T si_conv;
    int si_memtot;
    int si_verbose;
    int si_msg_count;
    char_u *si_info;
    int si_region_count;
    char_u si_region_name [MAXREGIONS * 2 + 1];
    garray_T si_rep;
    garray_T si_repsal;
    garray_T si_sal;
    char_u *si_sofofr;
    char_u *si_sofoto;
    int si_nosugfile;
    int si_nosplitsugs;
    int si_nocompoundsugs;
    int si_followup;
    int si_collapse;
    hashtab_T si_commonwords;
    time_t si_sugtime;
    int si_rem_accents;
    garray_T si_map;
    char_u *si_midword;
    int si_compmax;
    int si_compminlen;
    int si_compsylmax;
    int si_compoptions;
    garray_T si_comppat;
    char_u *si_compflags;
    char_u si_nobreak;
    char_u *si_syllable;
    garray_T si_prefcond;
    int si_newprefID;
    int si_newcompID;
};
struct wordnode_S {
    union {
        char_u hashkey [6];
        int index;
    } wn_u1;
    union {
        wordnode_T *next;
        wordnode_T *wnode;
    } wn_u2;
    wordnode_T *wn_child;
    wordnode_T *wn_sibling;
    int wn_refs;
    char_u wn_byte;
    char_u wn_affixID;
    short_u wn_flags;
    short  wn_region;
};
struct sblock_S {
    int sb_used;
    sblock_T *sb_next;
    char_u sb_data [1];
};
struct compitem_S {
    char_u ci_key [AH_KEY_LEN];
    unsigned  ci_flag;
    int ci_newID;
};
struct digraph {
    char_u char1;
    char_u char2;
    result_T result;
};
struct quality_pair {
    char *name;
    DWORD quality;
};
struct charset_pair {
    char *name;
    BYTE charset;
};
struct efm_S {
    regprog_T *prog;
    efm_T *next;
    char_u addr [FMT_PATTERNS];
    char_u prefix;
    char_u flags;
    int conthere;
};
struct qf_list_S {
    int_u qf_id;
    qfline_T *qf_start;
    qfline_T *qf_last;
    qfline_T *qf_ptr;
    int qf_count;
    int qf_index;
    int qf_nonevalid;
    char_u *qf_title;
    typval_T *qf_ctx;
    struct dir_stack_T *qf_dir_stack;
    char_u *qf_directory;
    struct dir_stack_T *qf_file_stack;
    char_u *qf_currfile;
    int qf_multiline;
    int qf_multiignore;
    int qf_multiscan;
    long  qf_changedtick;
};
struct nv_cmd {
    int cmd_char;
    nv_func_T cmd_func;
    short_u cmd_flags;
    short  cmd_arg;
};
struct nfa_pim_S {
    int result;
    nfa_state_T *state;
    regsubs_T subs;
    union {
        lpos_T pos;
        char_u *ptr;
    } end;
};
struct block_def {
    int startspaces;
    int endspaces;
    int textlen;
    char_u *textstart;
    colnr_T textcol;
    colnr_T start_vcol;
    colnr_T end_vcol;
    int is_short;
    int is_MAX;
    int is_oneChar;
    int pre_whitesp;
    int pre_whitesp_c;
    colnr_T end_char_vcols;
    colnr_T start_char_vcols;
};
struct fst {
    char *f_name;
    char f_min_argc;
    char f_max_argc;
    void (*f_func) (typval_T *args, typval_T *rvar);
};
struct sign {
    sign_T *sn_next;
    int sn_typenr;
    char_u *sn_name;
    char_u *sn_icon;
    char_u *sn_text;
    int sn_line_hl;
    int sn_text_hl;
};
struct tagNMTTDISPINFO_NEW {
    NMHDR hdr;
    LPSTR lpszText;
    char szText [80];
    HINSTANCE hinst;
    UINT uFlags;
    LPARAM lParam;
} NMTTDISPINFO_NEW;
struct tagTOOLINFOA_NEW {
    UINT cbSize;
    UINT uFlags;
    HWND hwnd;
    UINT_PTR uId;
    RECT rect;
    HINSTANCE hinst;
    LPSTR lpszText;
    LPARAM lParam;
} TOOLINFO_NEW;
struct cmdmod {
    char *name;
    int minlen;
    int has_count;
};
struct loop_cookie {
    garray_T *lines_gap;
    int current_line;
    int repeating;
    char_u * (*getline) (int, void *, int);
    void *cookie;
};
struct ucmd {
    char_u *uc_name;
    long_u uc_argt;
    char_u *uc_rep;
    long  uc_def;
    int uc_compl;
    int uc_addr_type;
    scid_T uc_scriptID;
    char_u *uc_compl_arg;
};
struct source_cookie {
    FILE *fp;
    char_u *nextline;
    int finished;
    linenr_T breakpoint;
    char_u *fname;
    int dbg_tick;
    int level;
};
struct debuggy {
    int dbg_nr;
    int dbg_type;
    char_u *dbg_name;
    regprog_T *dbg_prog;
    linenr_T dbg_lnum;
    int dbg_forceit;
    typval_T *dbg_val;
    int dbg_level;
};
struct sn_prl_S {
    int snp_count;
    proftime_T sn_prl_total;
    proftime_T sn_prl_self;
};
struct scriptitem_S {
    char_u *sn_name;
    int sn_dev_valid;
    dev_t sn_dev;
    ino_t sn_ino;
    int sn_prof_on;
    int sn_pr_force;
    proftime_T sn_pr_child;
    int sn_pr_nest;
    int sn_pr_count;
    proftime_T sn_pr_total;
    proftime_T sn_pr_self;
    proftime_T sn_pr_start;
    proftime_T sn_pr_children;
    garray_T sn_prl_ga;
    proftime_T sn_prl_start;
    proftime_T sn_prl_children;
    proftime_T sn_prl_wait;
    int sn_prl_idx;
    int sn_prl_execed;
};
struct join_S {
    char_u *s;
    char_u *tofree;
};
struct compl_S {
    compl_T *cp_next;
    compl_T *cp_prev;
    char_u *cp_str;
    char cp_icase;
    char_u * (cp_text [CPT_COUNT]);
    char_u *cp_fname;
    int cp_flags;
    int cp_number;
};
struct signalinfo {
    int sig;
    char *name;
    char deadly;
};
struct vimvar {
    char *vv_name;
    dictitem16_T vv_di;
    char vv_flags;
};
struct bw_info {
    int bw_fd;
    char_u *bw_buf;
    int bw_len;
    buf_T *bw_buffer;
};
struct msgchunk_S {
    msgchunk_T *sb_next;
    msgchunk_T *sb_prev;
    char sb_eol;
    int sb_msg_col;
    int sb_attr;
    char_u sb_text [1];
};
struct msg_hist {
    struct msg_hist *next;
    char_u *msg;
    int attr;
};
struct block0 {
    char_u b0_id [2];
    char_u b0_version [10];
    char_u b0_page_size [4];
    char_u b0_mtime [4];
    char_u b0_ino [4];
    char_u b0_pid [4];
    char_u b0_uname [B0_UNAME_SIZE];
    char_u b0_hname [B0_HNAME_SIZE];
    char_u b0_fname [B0_FNAME_SIZE_ORG];
    long  b0_magic_long;
    int b0_magic_int;
    short  b0_magic_short;
    char_u b0_magic_char;
};
struct data_block {
    short_u db_id;
    unsigned  db_free;
    unsigned  db_txt_start;
    unsigned  db_txt_end;
    linenr_T db_line_count;
    unsigned  db_index [1];
};
struct pointer_block {
    short_u pb_id;
    short_u pb_count;
    short_u pb_count_max;
    PTR_EN pb_pointer [1];
};
struct pointer_entry {
    blocknr_T pe_bnum;
    linenr_T pe_line_count;
    linenr_T pe_old_lnum;
    int pe_page_count;
};
struct regstar_S {
    int nextb;
    int nextb_ic;
    long  count;
    long  minval;
    long  maxval;
};
struct regitem_S {
    regstate_T rs_state;
    char_u *rs_scan;
    union {
        save_se_T sesave;
        regsave_T regsave;
    } rs_un;
    short  rs_no;
};
struct regbehind_S {
    regsave_T save_after;
    regsave_T save_behind;
    int save_need_clear_subexpr;
    save_se_T save_start [NSUBEXP];
    save_se_T save_end [NSUBEXP];
};
struct mousetable {
    int pseudo_code;
    int button;
    int is_click;
    int is_drag;
};
struct modmasktable {
    short  mod_mask;
    short  mod_flag;
    char_u name;
};
struct syl_item_S {
    char_u sy_chars [SY_MAXLEN];
    int sy_len;
};
struct spelload_S {
    char_u sl_lang [MAXWLEN + 1];
    slang_T *sl_slang;
    int sl_nobreak;
};
struct suggest_S {
    char_u *st_word;
    int st_wordlen;
    int st_orglen;
    int st_score;
    int st_altscore;
    int st_salscore;
    int st_had_bonus;
    slang_T *st_slang;
};
struct suginfo_S {
    garray_T su_ga;
    int su_maxcount;
    int su_maxscore;
    int su_sfmaxscore;
    garray_T su_sga;
    char_u *su_badptr;
    int su_badlen;
    int su_badflags;
    char_u su_badword [MAXWLEN];
    char_u su_fbadword [MAXWLEN];
    char_u su_sal_badword [MAXWLEN];
    hashtab_T su_banned;
    slang_T *su_sallang;
};
struct listvar_S {
    listitem_T *lv_first;
    listitem_T *lv_last;
    int lv_refcount;
    int lv_len;
    listwatch_T *lv_watch;
    int lv_idx;
    listitem_T *lv_idx_item;
    int lv_copyID;
    list_T *lv_copylist;
    char lv_lock;
    list_T *lv_used_next;
    list_T *lv_used_prev;
};
struct attr_entry {
    short  ae_attr;
    union {
        struct {
            char_u *start;
            char_u *stop;
        } term;
        struct {
            short_u fg_color;
            short_u bg_color;
            guicolor_T fg_rgb;
            guicolor_T bg_rgb;
        } cterm;
        struct {
            guicolor_T fg_color;
            guicolor_T bg_color;
            guicolor_T sp_color;
            GuiFont font;
        } gui;
    } ae_u;
};
struct initmap {
    char_u *arg;
    int mode;
};
struct dictitem16_S {
    typval_T di_tv;
    char_u di_flags;
    char_u di_key [17];
};
struct mapblock {
    mapblock_T *m_next;
    char_u *m_keys;
    char_u *m_str;
    char_u *m_orig_str;
    int m_keylen;
    int m_mode;
    int m_noremap;
    char m_silent;
    char m_nowait;
    char m_expr;
    scid_T m_script_ID;
};
struct signlist {
    int id;
    linenr_T lnum;
    int typenr;
    signlist_T *next;
    signlist_T *prev;
};
struct u_header {
    union {
        u_header_T *ptr;
        long  seq;
    } uh_next;
    union {
        u_header_T *ptr;
        long  seq;
    } uh_prev;
    union {
        u_header_T *ptr;
        long  seq;
    } uh_alt_next;
    union {
        u_header_T *ptr;
        long  seq;
    } uh_alt_prev;
    long  uh_seq;
    int uh_walk;
    u_entry_T *uh_entry;
    u_entry_T *uh_getbot_entry;
    pos_T uh_cursor;
    long  uh_cursor_vcol;
    int uh_flags;
    pos_T uh_namedm [NMARKS];
    visualinfo_T uh_visual;
    time_T uh_time;
    long  uh_save_nr;
};
struct wininfo_S {
    wininfo_T *wi_next;
    wininfo_T *wi_prev;
    win_T *wi_win;
    pos_T wi_fpos;
    int wi_optset;
    winopt_T wi_opt;
    int wi_fold_manual;
    garray_T wi_folds;
};
struct msglist {
    char_u *msg;
    char_u *throw_msg;
    struct msglist *next;
};
struct spat {
    char_u *pat;
    int magic;
    int no_scs;
    struct soffset off;
};
struct sp_syn {
    int inc_tag;
    short  id;
    short  *cont_in_list;
};
struct stl_hlrec {
    char_u *start;
    int userhl;
};
struct server_id {
    HWND hwnd;
    char_u *name;
};
struct regprog {
    regengine_T *engine;
    unsigned  regflags;
    unsigned  re_engine;
    unsigned  re_flags;
};
struct hashtable_S {
    long_u ht_mask;
    long_u ht_used;
    long_u ht_filled;
    int ht_locked;
    int ht_error;
    hashitem_T *ht_array;
    hashitem_T ht_smallarray [HT_INIT_SIZE];
};
struct mf_hashtab_S {
    long_u mht_mask;
    long_u mht_count;
    mf_hashitem_T **mht_buckets;
    mf_hashitem_T *mht_small_buckets [MHT_INIT_SIZE];
    char mht_fixed;
};
struct nfa_state {
    int c;
    nfa_state_T *out;
    nfa_state_T *out1;
    int id;
    int lastlist [2];
    int val;
};
struct syn_state {
    synstate_T *sst_next;
    linenr_T sst_lnum;
    union {
        bufstate_T sst_stack [SST_FIX_STATES];
        garray_T sst_ga;
    } sst_union;
    int sst_next_flags;
    int sst_stacksize;
    short  *sst_next_list;
    disptick_T sst_tick;
    linenr_T sst_change_lnum;
};
struct trystate_S {
    state_T ts_state;
    int ts_score;
    idx_T ts_arridx;
    short  ts_curi;
    char_u ts_fidx;
    char_u ts_fidxtry;
    char_u ts_twordlen;
    char_u ts_prefixdepth;
    char_u ts_flags;
    char_u ts_prewordlen;
    char_u ts_splitoff;
    char_u ts_splitfidx;
    char_u ts_complen;
    char_u ts_compsplit;
    char_u ts_save_badflags;
    char_u ts_delidx;
};
struct regengine {
    regprog_T * (*regcomp) (char_u *, int);
    void (*regfree) (regprog_T *);
    int (*regexec_nl) (regmatch_T *, char_u *, colnr_T, int);
    long  (*regexec_multi) (regmmatch_T *, win_T *, buf_T *, linenr_T, colnr_T, proftime_T *, int *);
    char_u *expr;
};
struct posmatch {
    llpos_T pos [MAXPOSMATCH];
    int cur;
    linenr_T toplnum;
    linenr_T botlnum;
};
struct matchinf_S {
    langp_T *mi_lp;
    char_u *mi_word;
    char_u *mi_end;
    char_u *mi_fend;
    char_u *mi_cend;
    char_u mi_fword [MAXWLEN + 1];
    int mi_fwordlen;
    int mi_prefarridx;
    int mi_prefcnt;
    int mi_prefixlen;

    # define mi_cprefixlen mi_prefixlen	/* it's the same value */
    int mi_compoff;
    char_u mi_compflags [MAXWLEN];
    int mi_complen;
    int mi_compextra;
    int mi_result;
    int mi_capflags;
    win_T *mi_win;
    int mi_result2;
    char_u *mi_end2;
};
struct wordcount_S {
    short_u wc_count;
    char_u wc_word [1];
};
struct vim_exception {
    except_type_T type;
    char_u *value;
    struct msglist *messages;
    char_u *throw_name;
    linenr_T throw_lnum;
    except_T *caught;
};
struct buf_state {
    int bs_idx;
    int bs_flags;
    int bs_seqnr;
    int bs_cchar;
    reg_extmatch_T *bs_extmatch;
};
struct fmtpattern {
    char_u convchar;
    char *pattern;
};
struct memline {
    linenr_T ml_line_count;
    memfile_T *ml_mfp;

    #define ML_EMPTY	1	/* empty buffer */

    #define ML_LINE_DIRTY	2	/* cached line was changed and allocated */

    #define ML_LOCKED_DIRTY	4	/* ml_locked was changed */

    #define ML_LOCKED_POS	8	/* ml_locked needs positive block number */
    int ml_flags;
    infoptr_T *ml_stack;
    int ml_stack_top;
    int ml_stack_size;
    linenr_T ml_line_lnum;
    char_u *ml_line_ptr;
    bhdr_T *ml_locked;
    linenr_T ml_locked_low;
    linenr_T ml_locked_high;
    int ml_locked_lineadd;
    chunksize_T *ml_chunksize;
    int ml_numchunks;
    int ml_usedchunks;
};
struct prt_dsc_line_S {
    int type;
    char_u *string;
    int len;
};
struct qfline_S {
    qfline_T *qf_next;
    qfline_T *qf_prev;
    linenr_T qf_lnum;
    int qf_fnum;
    int qf_col;
    int qf_nr;
    char_u *qf_pattern;
    char_u *qf_text;
    char_u qf_viscol;
    char_u qf_cleared;
    char_u qf_type;
    char_u qf_valid;
};
struct dir_stack_T {
    struct dir_stack_T *next;
    char_u *dirname;
};
struct cmdline_info {
    char_u *cmdbuff;
    int cmdbufflen;
    int cmdlen;
    int cmdpos;
    int cmdspos;
    int cmdfirstc;
    int cmdindent;
    char_u *cmdprompt;
    int cmdattr;
    int overstrike;
    expand_T *xpc;
    int xp_context;
    char_u *xp_arg;
    int input_fn;
};
struct sb_line_S {
    int sb_cols;
    cellattr_T *sb_cells;
    cellattr_T sb_fill_attr;
};
struct jobvar_S {
    job_T *jv_next;
    job_T *jv_prev;
    pid_t jv_pid;
    char_u *jv_tty_in;
    char_u *jv_tty_out;
    jobstatus_T jv_status;
    char_u *jv_stoponexit;
    int jv_exitval;
    char_u *jv_exit_cb;
    partial_T *jv_exit_partial;
    buf_T *jv_in_buf;
    int jv_refcount;
    int jv_copyID;
    channel_T *jv_channel;
};
struct keyentry {
    keyentry_T *ke_next;
    struct sp_syn k_syn;
    short  *next_list;
    int flags;
    int k_char;
    char_u keyword [1];
};
struct specialkey {
    KeySym key_sym;
    char_u vim_code0;
    char_u vim_code1;
};
struct keyqueue {
    char_u *keystr;
    struct keyqueue *next;
    struct keyqueue *prev;
};
struct matchitem {
    matchitem_T *next;
    int id;
    int priority;
    char_u *pattern;
    int hlg_id;
    regmmatch_T match;
    posmatch_T pos;
    match_T hl;
    int conceal_char;
};
struct w_line {
    linenr_T wl_lnum;
    short_u wl_size;
    char wl_valid;
    char wl_folded;
    linenr_T wl_lastlnum;
};
struct qf_info_S {
    int qf_refcount;
    int qf_listcount;
    int qf_curlist;
    qf_list_T qf_lists [LISTCOUNT];
};
struct dictitem_S {
    typval_T di_tv;
    char_u di_flags;
    char_u di_key [1];
};
struct dictvar_S {
    char dv_lock;
    char dv_scope;
    int dv_refcount;
    int dv_copyID;
    hashtab_T dv_hashtab;
    dict_T *dv_copydict;
    dict_T *dv_used_next;
    dict_T *dv_used_prev;
};
struct arglist {
    garray_T al_ga;
    int al_refcount;
    int id;
};
struct taggy {
    char_u *tagname;
    fmark_T fmark;
    int cur_match;
    int cur_fnum;
};
struct xfilemark {
    fmark_T fmark;
    char_u *fname;
    time_T time_set;
};
struct frame_S {
    char fr_layout;
    int fr_width;
    int fr_newwidth;
    int fr_height;
    int fr_newheight;
    frame_T *fr_parent;
    frame_T *fr_next;
    frame_T *fr_prev;
    frame_T *fr_child;
    win_T *fr_win;
};
struct nbbuf_struct {
    buf_T *bufp;
    unsigned  int fireChanges : 1;
    unsigned  int initDone : 1;
    unsigned  int insertDone : 1;
    unsigned  int modified : 1;
    int nbbuf_number;
    char *displayname;
    int *signmap;
    short_u signmaplen;
    short_u signmapused;
};
struct backpos_S {
    char_u *bp_scan;
    regsave_T bp_pos;
};
struct diffblock_S {
    diff_T *df_next;
    linenr_T df_lnum [DB_COUNT];
    linenr_T df_count [DB_COUNT];
};
struct file_buffer {
    memline_T b_ml;
    buf_T *b_next;
    buf_T *b_prev;
    int b_nwindows;
    int b_flags;
    int b_locked;
    char_u *b_ffname;
    char_u *b_sfname;
    char_u *b_fname;
    int b_dev_valid;
    dev_t b_dev;
    ino_t b_ino;
    int b_fnum;
    char_u b_key [VIM_SIZEOF_INT * 2 + 1];
    int b_changed;
    dictitem16_T b_ct_di;

    #define CHANGEDTICK(buf) ((buf)->b_ct_di.di_tv.vval.v_number)
    varnumber_T b_last_changedtick;
    varnumber_T b_last_changedtick_pum;
    int b_saving;
    int b_mod_set;
    linenr_T b_mod_top;
    linenr_T b_mod_bot;
    long  b_mod_xlines;
    wininfo_T *b_wininfo;
    long  b_mtime;
    long  b_mtime_read;
    off_T b_orig_size;
    int b_orig_mode;
    time_T b_last_used;
    pos_T b_namedm [NMARKS];
    visualinfo_T b_visual;
    int b_visual_mode_eval;
    pos_T b_last_cursor;
    pos_T b_last_insert;
    pos_T b_last_change;
    pos_T b_changelist [JUMPLISTSIZE];
    int b_changelistlen;
    int b_new_change;
    char_u b_chartab [32];
    mapblock_T * (b_maphash [256]);
    mapblock_T *b_first_abbr;
    garray_T b_ucmds;
    pos_T b_op_start;
    pos_T b_op_start_orig;
    pos_T b_op_end;
    int b_marks_read;
    u_header_T *b_u_oldhead;
    u_header_T *b_u_newhead;
    u_header_T *b_u_curhead;
    int b_u_numhead;
    int b_u_synced;
    long  b_u_seq_last;
    long  b_u_save_nr_last;
    long  b_u_seq_cur;
    time_T b_u_time_cur;
    long  b_u_save_nr_cur;
    char_u *b_u_line_ptr;
    linenr_T b_u_line_lnum;
    colnr_T b_u_line_colnr;
    int b_scanned;
    long  b_p_iminsert;
    long  b_p_imsearch;

    #define B_IMODE_USE_INSERT -1	/*	Use b_p_iminsert value for search */

    #define B_IMODE_NONE 0		/*	Input via none */

    #define B_IMODE_LMAP 1		/*	Input via langmap */

    #define B_IMODE_IM 2		/*	Input via input method */

    #define B_IMODE_LAST 2
    short  b_kmap_state;

    # define KEYMAP_INIT	1	/* 'keymap' was set, call keymap_init() */

    # define KEYMAP_LOADED	2	/* 'keymap' mappings have been loaded */
    garray_T b_kmap_ga;
    int b_p_initialized;
    int b_p_scriptID [BV_COUNT];
    int b_p_ai;
    int b_p_ai_nopaste;
    char_u *b_p_bkc;
    unsigned  b_bkc_flags;
    int b_p_ci;
    int b_p_bin;
    char_u *b_p_bh;
    char_u *b_p_bt;

    #define BUF_HAS_QF_ENTRY 1

    #define BUF_HAS_LL_ENTRY 2
    int b_has_qf_entry;
    int b_p_bl;
    int b_p_cin;
    char_u *b_p_cino;
    char_u *b_p_cink;
    char_u *b_p_cinw;
    char_u *b_p_com;
    char_u *b_p_cms;
    char_u *b_p_cpt;
    int b_p_eol;
    int b_p_fixeol;
    int b_p_et;
    int b_p_et_nobin;
    int b_p_et_nopaste;
    char_u *b_p_ff;
    char_u *b_p_ft;
    char_u *b_p_fo;
    char_u *b_p_flp;
    int b_p_inf;
    char_u *b_p_isk;
    char_u *b_p_def;
    char_u *b_p_inc;
    char_u *b_p_inex;
    long_u b_p_inex_flags;
    char_u *b_p_inde;
    long_u b_p_inde_flags;
    char_u *b_p_indk;
    char_u *b_p_fp;
    char_u *b_p_fex;
    long_u b_p_fex_flags;
    char_u *b_p_key;
    char_u *b_p_kp;
    int b_p_lisp;
    char_u *b_p_mps;
    int b_p_ml;
    int b_p_ml_nobin;
    int b_p_ma;
    char_u *b_p_nf;
    int b_p_pi;
    char_u *b_p_qe;
    int b_p_ro;
    long  b_p_sw;
    int b_p_sn;
    int b_p_si;
    long  b_p_sts;
    long  b_p_sts_nopaste;
    char_u *b_p_sua;
    int b_p_swf;
    long  b_p_smc;
    char_u *b_p_syn;
    long  b_p_ts;
    int b_p_tx;
    long  b_p_tw;
    long  b_p_tw_nobin;
    long  b_p_tw_nopaste;
    long  b_p_wm;
    long  b_p_wm_nobin;
    long  b_p_wm_nopaste;
    char_u *b_p_keymap;
    char_u *b_p_gp;
    char_u *b_p_mp;
    char_u *b_p_efm;
    char_u *b_p_ep;
    char_u *b_p_path;
    int b_p_ar;
    char_u *b_p_tags;
    char_u *b_p_tc;
    unsigned  b_tc_flags;
    char_u *b_p_dict;
    char_u *b_p_tsr;
    long  b_p_ul;
    int b_p_udf;
    int b_p_mmta;
    char_u *b_p_lw;
    int b_ind_level;
    int b_ind_open_imag;
    int b_ind_no_brace;
    int b_ind_first_open;
    int b_ind_open_extra;
    int b_ind_close_extra;
    int b_ind_open_left_imag;
    int b_ind_jump_label;
    int b_ind_case;
    int b_ind_case_code;
    int b_ind_case_break;
    int b_ind_param;
    int b_ind_func_type;
    int b_ind_comment;
    int b_ind_in_comment;
    int b_ind_in_comment2;
    int b_ind_cpp_baseclass;
    int b_ind_continuation;
    int b_ind_unclosed;
    int b_ind_unclosed2;
    int b_ind_unclosed_noignore;
    int b_ind_unclosed_wrapped;
    int b_ind_unclosed_whiteok;
    int b_ind_matching_paren;
    int b_ind_paren_prev;
    int b_ind_maxparen;
    int b_ind_maxcomment;
    int b_ind_scopedecl;
    int b_ind_scopedecl_code;
    int b_ind_java;
    int b_ind_js;
    int b_ind_keep_case_label;
    int b_ind_hash_comment;
    int b_ind_cpp_namespace;
    int b_ind_if_for_while;
    int b_ind_cpp_extern_c;
    linenr_T b_no_eol_lnum;
    int b_start_eol;
    int b_start_ffc;
    dictitem_T b_bufvar;
    dict_T *b_vars;
    char_u *b_p_bexpr;
    long_u b_p_bexpr_flags;
    char_u *b_p_cm;
    int b_may_swap;
    int b_did_warn;
    int b_help;
    int b_spell;
    int b_shortname;
    synblock_T b_s;
    signlist_T *b_signlist;
    int b_has_sign_column;
    int b_netbeans_file;
    int b_was_netbeans_file;
    int b_write_to_channel;
    cryptstate_T *b_cryptstate;
    int b_mapped_ctrl_c;
    term_T *b_term;
};
struct cleanup_stuff {
    int pending;
    except_T *exception;
};
struct buffheader {
    buffblock_T bh_first;
    buffblock_T *bh_curr;
    int bh_index;
    int bh_space;
};
struct buffblock {
    buffblock_T *b_next;
    char_u b_str [1];
};
struct prt_resfile_buffer_S {
    char_u buffer [PRT_FILE_BUFFER_LEN];
    int len;
    int line_start;
    int line_end;
};
struct affheader_S {
    char_u ah_key [AH_KEY_LEN];
    unsigned  ah_flag;
    int ah_newID;
    int ah_combine;
    int ah_follows;
    affentry_T *ah_first;
};
struct affentry_S {
    affentry_T *ae_next;
    char_u *ae_chop;
    char_u *ae_add;
    char_u *ae_flags;
    char_u *ae_cond;
    regprog_T *ae_prog;
    char ae_compforbid;
    char ae_comppermit;
};
struct afffile_S {
    char_u *af_enc;
    int af_flagtype;
    unsigned  af_rare;
    unsigned  af_keepcase;
    unsigned  af_bad;
    unsigned  af_needaffix;
    unsigned  af_circumfix;
    unsigned  af_needcomp;
    unsigned  af_comproot;
    unsigned  af_compforbid;
    unsigned  af_comppermit;
    unsigned  af_nosuggest;
    int af_pfxpostpone;
    int af_ignoreextra;
    hashtab_T af_pref;
    hashtab_T af_suff;
    hashtab_T af_comp;
};
struct soffset {
    int dir;
    int line;
    int end;
    long  off;
};
struct dbg_stuff {
    int trylevel;
    int force_abort;
    except_T *caught_stack;
    char_u *vv_exception;
    char_u *vv_throwpoint;
    int did_emsg;
    int got_int;
    int did_throw;
    int need_rethrow;
    int check_cstack;
    except_T *current_exception;
};
struct ff_search_ctx_T {
    ff_stack_T *ffsc_stack_ptr;
    ff_visited_list_hdr_T *ffsc_visited_list;
    ff_visited_list_hdr_T *ffsc_dir_visited_list;
    ff_visited_list_hdr_T *ffsc_visited_lists_list;
    ff_visited_list_hdr_T *ffsc_dir_visited_lists_list;
    char_u *ffsc_file_to_search;
    char_u *ffsc_start_dir;
    char_u *ffsc_fix_path;
    char_u *ffsc_wc_path;
    int ffsc_level;
    char_u **ffsc_stopdirs_v;
    int ffsc_find_what;
    int ffsc_tagfile;
};
struct ff_visited_list_hdr {
    struct ff_visited_list_hdr *ffvl_next;
    char_u *ffvl_filename;
    ff_visited_T *ffvl_visited_list;
};
struct ff_visited {
    struct ff_visited *ffv_next;
    char_u *ffv_wc_path;
    int ffv_dev_valid;
    dev_t ffv_dev;
    ino_t ffv_ino;
    char_u ffv_fname [1];
};
struct ff_stack {
    struct ff_stack *ffs_prev;
    char_u *ffs_fix_path;
    char_u *ffs_wc_path;
    char_u **ffs_filearray;
    int ffs_filearray_size;
    char_u ffs_filearray_cur;
    int ffs_stage;
    int ffs_level;
    int ffs_star_star_empty;
};
struct ml_chunksize {
    int mlcs_numlines;
    long  mlcs_totalsize;
};
struct prt_mediasize_S {
    char *name;
    float width;
    float height;
};
struct event_name {
    char *name;
    event_T event;
};
struct key_name_entry {
    int key;
    char_u *name;
};
struct growarray {
    int ga_len;
    int ga_maxlen;
    int ga_itemsize;
    int ga_growsize;
    void *ga_data;
};
struct terminal_S {
    term_T *tl_next;
    VTerm *tl_vterm;
    job_T *tl_job;
    buf_T *tl_buffer;
    int tl_vterm_size_changed;
    int tl_tty_fd;
    char_u *tl_tty_in;
    char_u *tl_tty_out;
    int tl_normal_mode;
    int tl_channel_closed;
    int tl_finish;
    char_u *tl_opencmd;
    char_u *tl_eof_chars;
    int tl_rows;
    int tl_cols;
    int tl_rows_fixed;
    int tl_cols_fixed;
    char_u *tl_title;
    char_u *tl_status_text;
    int tl_dirty_row_start;
    int tl_dirty_row_end;
    garray_T tl_scrollback;
    int tl_scrollback_scrolled;
    cellattr_T tl_default_color;
    VTermPos tl_cursor_pos;
    int tl_cursor_visible;
    int tl_cursor_blink;
    int tl_cursor_shape;
    char_u *tl_cursor_color;
    int tl_using_altscreen;
};
struct termcode {
    char_u name [2];
    char_u *code;
    int len;
    int modlen;
};
struct window_S {
    int w_id;
    buf_T *w_buffer;
    synblock_T *w_s;
    win_T *w_prev;
    win_T *w_next;
    int w_closing;
    frame_T *w_frame;
    pos_T w_cursor;
    colnr_T w_curswant;
    int w_set_curswant;
    char w_old_visual_mode;
    linenr_T w_old_cursor_lnum;
    colnr_T w_old_cursor_fcol;
    colnr_T w_old_cursor_lcol;
    linenr_T w_old_visual_lnum;
    colnr_T w_old_visual_col;
    colnr_T w_old_curswant;
    linenr_T w_topline;
    char w_topline_was_set;
    int w_topfill;
    int w_old_topfill;
    int w_botfill;
    int w_old_botfill;
    colnr_T w_leftcol;
    colnr_T w_skipcol;
    int w_winrow;
    int w_height;
    int w_status_height;
    int w_wincol;
    int w_width;
    int w_vsep_width;
    int w_valid;
    pos_T w_valid_cursor;
    colnr_T w_valid_leftcol;
    int w_cline_height;
    int w_cline_folded;
    int w_cline_row;
    colnr_T w_virtcol;
    int w_wrow, w_wcol;
    linenr_T w_botline;
    int w_empty_rows;
    int w_filler_rows;
    int w_lines_valid;
    wline_T *w_lines;
    garray_T w_folds;
    char w_fold_manual;
    char w_foldinvalid;
    int w_nrwidth;
    int w_redr_type;
    int w_upd_rows;
    linenr_T w_redraw_top;
    linenr_T w_redraw_bot;
    int w_redr_status;
    pos_T w_ru_cursor;
    colnr_T w_ru_virtcol;
    linenr_T w_ru_topline;
    linenr_T w_ru_line_count;
    int w_ru_topfill;
    char w_ru_empty;
    int w_alt_fnum;
    alist_T *w_alist;
    int w_arg_idx;
    int w_arg_idx_invalid;
    char_u *w_localdir;
    vimmenu_T *w_winbar;
    winbar_item_T *w_winbar_items;
    int w_winbar_height;
    winopt_T w_onebuf_opt;
    winopt_T w_allbuf_opt;
    long_u w_p_stl_flags;
    long_u w_p_fde_flags;
    long_u w_p_fdt_flags;
    int *w_p_cc_cols;
    int w_p_brimin;
    int w_p_brishift;
    int w_p_brisbr;

    #define GLOBAL_WO(p)	((char *)p + sizeof(winopt_T))
    long  w_scbind_pos;
    dictitem_T w_winvar;
    dict_T *w_vars;
    int w_farsi;
    pos_T w_pcmark;
    pos_T w_prev_pcmark;
    xfmark_T w_jumplist [JUMPLISTSIZE];
    int w_jumplistlen;
    int w_jumplistidx;
    int w_changelistidx;
    matchitem_T *w_match_head;
    int w_next_match_id;
    taggy_T w_tagstack [TAGSTACKSIZE];
    int w_tagstackidx;
    int w_tagstacklen;
    int w_fraction;
    int w_prev_fraction_row;
    scrollbar_T w_scrollbars [2];
    linenr_T w_nrwidth_line_count;
    long  w_nuw_cached;
    int w_nrwidth_width;
    qf_info_T *w_llist;
    qf_info_T *w_llist_ref;
};
struct builtin_term {
    int bt_entry;
    char *bt_string;
};
static struct {
    VTermEncodingType type;
    char designation;
    VTermEncoding *enc;
} encodings [] = {{ENC_UTF8, 'u', &encoding_utf8}, {ENC_SINGLE_94, '0', (VTermEncoding *) &encoding_DECdrawing}, {ENC_SINGLE_94, 'A', (VTermEncoding *) &encoding_uk}, {ENC_SINGLE_94, 'B', &encoding_usascii}, {0, 0, NULL},};
OutputObject Output = {PyObject_HEAD_INIT (&OutputType) 0, 0
};
writefn old_fn = NULL;
EXTERN int p_write;
EXTERN int p_wmnu;
EXTERN int p_warn;
EXTERN char_u *p_viminfofile;
EXTERN char_u *p_viminfo;
EXTERN long  p_ut;
EXTERN char_u *p_ttym;
EXTERN int p_tf;
EXTERN int p_tbi;
EXTERN int p_ta;
EXTERN int p_tr;
EXTERN long  p_tl;
EXTERN char_u *p_tal;
EXTERN long  p_tpm;
EXTERN char_u *p_rtp;
EXTERN long  p_report;
EXTERN long  p_rdt;
EXTERN char_u *p_pt;
EXTERN long  p_mmt;
EXTERN long  p_mat;
EXTERN int p_lnr;
EXTERN char_u *p_langmap;
EXTERN int p_prompt;
EXTERN char_u *p_popt;
EXTERN char_u *p_pfn;
EXTERN char_u *p_breakat;
EXTERN char *ignoredp;
EXTERN int ignored;
EXTERN char_u e_nbreadonly [] INIT (= N_ ("E744: NetBeans does not allow changes in read-only files"));
EXTERN char_u e_write [] INIT (= N_ ("E80: Error while writing"));
EXTERN char_u e_wildexpand [] INIT (= N_ ("E79: Cannot expand wildcards"));
EXTERN char_u e_trailing [] INIT (= N_ ("E488: Trailing characters"));
EXTERN char_u e_readonly [] INIT (= N_ ("E45: 'readonly' option is set (add ! to override)"));
EXTERN char_u e_number_exp [] INIT (= N_ ("E39: Number expected"));
EXTERN char_u e_null [] INIT (= N_ ("E38: Null argument"));
EXTERN char_u e_notread [] INIT (= N_ ("E485: Can't read file %s"));
EXTERN char_u e_norange [] INIT (= N_ ("E481: No range allowed"));
EXTERN char_u e_nomap [] INIT (= N_ ("E31: No such mapping"));
EXTERN char_u e_nobang [] INIT (= N_ ("E477: No ! allowed"));
EXTERN char_u e_noabbr [] INIT (= N_ ("E24: No such abbreviation"));
EXTERN char_u e_noalt [] INIT (= N_ ("E23: No alternate file"));
EXTERN char_u e_invrange [] INIT (= N_ ("E16: Invalid range"));
EXTERN char_u e_interr [] INIT (= N_ ("Interrupted"));
EXTERN char_u e_intern2 [] INIT (= N_ ("E685: Internal error: %s"));
EXTERN char_u e_internal [] INIT (= N_ ("E473: Internal error"));
EXTERN char_u e_abort [] INIT (= N_ ("E470: Command aborted"));
EXTERN linenr_T printer_page_num;
VTerm *vt;
int prt_tumble;
int prt_portrait;
int prt_media;
int prt_page_num;
float prt_text_run;
taggy_T ptag_entry = {NULL, {INIT_POS_T (0, 0, 0), 0}, 0, 0};
int menu_enabled = TRUE;
Widget menuBar;
Widget textArea;
VALUE eDeletedWindowError;
VALUE objtbl;
int ruby_initialized = 0;
digr_T digraphdefault [] = {{'N', 'U', 0x0a}, {'S', 'H', 0x01}, {'S', 'X', 0x02}, {'E', 'X', 0x03}, {'E', 'T', 0x04}, {'E', 'Q', 0x05}, {'A', 'K', 0x06}, {'B', 'L', 0x07}, {'B', 'S', 0x08}, {'H', 'T', 0x09}, {'L', 'F', 0x0a}, {'V', 'T', 0x0b}, {'F', 'F', 0x0c}, {'C', 'R', 0x0d}, {'S', 'O', 0x0e}, {'S', 'I', 0x0f}, {'D', 'L', 0x10}, {'D', '1', 0x11}, {'D', '2', 0x12}, {'D', '3', 0x13}, {'D', '4', 0x14}, {'N', 'K', 0x15}, {'S', 'Y', 0x16}, {'E', 'B', 0x17}, {'C', 'N', 0x18}, {'E', 'M', 0x19}, {'S', 'B', 0x1a}, {'E', 'C', 0x1b}, {'F', 'S', 0x1c}, {'G', 'S', 0x1d}, {'R', 'S', 0x1e}, {'U', 'S', 0x1f}, {'S', 'P', 0x20}, {'N', 'b', 0x23}, {'D', 'O', 0x24}, {'A', 't', 0x40}, {'<', '(', 0x5b}, {'/', '/', 0x5c}, {')', '>', 0x5d}, {'\'', '>', 0x5e}, {'\'', '!', 0x60}, {'(', '!', 0x7b}, {'!', '!', 0x7c}, {'!', ')', 0x7d}, {'\'', '?', 0x7e}, {'D', 'T', 0x7f}, {'P', 'A', 0x80}, {'H', 'O', 0x81}, {'B', 'H', 0x82}, {'N', 'H', 0x83}, {'I', 'N', 0x84}, {'N', 'L', 0x85}, {'S', 'A', 0x86}, {'E', 'S', 0x87}, {'H', 'S', 0x88}, {'H', 'J', 0x89}, {'V', 'S', 0x8a}, {'P', 'D', 0x8b}, {'P', 'U', 0x8c}, {'R', 'I', 0x8d}, {'S', '2', 0x8e}, {'S', '3', 0x8f}, {'D', 'C', 0x90}, {'P', '1', 0x91}, {'P', '2', 0x92}, {'T', 'S', 0x93}, {'C', 'C', 0x94}, {'M', 'W', 0x95}, {'S', 'G', 0x96}, {'E', 'G', 0x97}, {'S', 'S', 0x98}, {'G', 'C', 0x99}, {'S', 'C', 0x9a}, {'C', 'I', 0x9b}, {'S', 'T', 0x9c}, {'O', 'C', 0x9d}, {'P', 'M', 0x9e}, {'A', 'C', 0x9f}, {'N', 'S', 0xa0}, {'!', 'I', 0xa1}, {'C', 't', 0xa2}, {'P', 'd', 0xa3}, {'C', 'u', 0xa4}, {'Y', 'e', 0xa5}, {'B', 'B', 0xa6}, {'S', 'E', 0xa7}, {'\'', ':', 0xa8}, {'C', 'o', 0xa9}, {'-', 'a', 0xaa}, {'<', '<', 0xab}, {'N', 'O', 0xac}, {'-', '-', 0xad}, {'R', 'g', 0xae}, {'\'', 'm', 0xaf}, {'D', 'G', 0xb0}, {'+', '-', 0xb1}, {'2', 'S', 0xb2}, {'3', 'S', 0xb3}, {'\'', '\'', 0xb4}, {'M', 'y', 0xb5}, {'P', 'I', 0xb6}, {'.', 'M', 0xb7}, {'\'', ',', 0xb8}, {'1', 'S', 0xb9}, {'-', 'o', 0xba}, {'>', '>', 0xbb}, {'1', '4', 0xbc}, {'1', '2', 0xbd}, {'3', '4', 0xbe}, {'?', 'I', 0xbf}, {'A', '!', 0xc0}, {'A', '\'', 0xc1}, {'A', '>', 0xc2}, {'A', '?', 0xc3}, {'A', ':', 0xc4}, {'A', 'A', 0xc5}, {'A', 'E', 0xc6}, {'C', ',', 0xc7}, {'E', '!', 0xc8}, {'E', '\'', 0xc9}, {'E', '>', 0xca}, {'E', ':', 0xcb}, {'I', '!', 0xcc}, {'I', '\'', 0xcd}, {'I', '>', 0xce}, {'I', ':', 0xcf}, {'D', '-', 0xd0}, {'N', '?', 0xd1}, {'O', '!', 0xd2}, {'O', '\'', 0xd3}, {'O', '>', 0xd4}, {'O', '?', 0xd5}, {'O', ':', 0xd6}, {'*', 'X', 0xd7}, {'O', '/', 0xd8}, {'U', '!', 0xd9}, {'U', '\'', 0xda}, {'U', '>', 0xdb}, {'U', ':', 0xdc}, {'Y', '\'', 0xdd}, {'T', 'H', 0xde}, {'s', 's', 0xdf}, {'a', '!', 0xe0}, {'a', '\'', 0xe1}, {'a', '>', 0xe2}, {'a', '?', 0xe3}, {'a', ':', 0xe4}, {'a', 'a', 0xe5}, {'a', 'e', 0xe6}, {'c', ',', 0xe7}, {'e', '!', 0xe8}, {'e', '\'', 0xe9}, {'e', '>', 0xea}, {'e', ':', 0xeb}, {'i', '!', 0xec}, {'i', '\'', 0xed}, {'i', '>', 0xee}, {'i', ':', 0xef}, {'d', '-', 0xf0}, {'n', '?', 0xf1}, {'o', '!', 0xf2}, {'o', '\'', 0xf3}, {'o', '>', 0xf4}, {'o', '?', 0xf5}, {'o', ':', 0xf6}, {'-', ':', 0xf7}, {'o', '/', 0xf8}, {'u', '!', 0xf9}, {'u', '\'', 0xfa}, {'u', '>', 0xfb}, {'u', ':', 0xfc}, {'y', '\'', 0xfd}, {'t', 'h', 0xfe}, {'y', ':', 0xff}, {'~', '!', 161}, {'c', '|', 162}, {'$', '$', 163}, {'o', 'x', 164}, {'Y', '-', 165}, {'|', '|', 166}, {'c', 'O', 169}, {'-', ',', 172}, {'-', '=', 175}, {'~', 'o', 176}, {'2', '2', 178}, {'3', '3', 179}, {'p', 'p', 182}, {'~', '.', 183}, {'1', '1', 185}, {'~', '?', 191}, {'A', '`', 192}, {'A', '^', 194}, {'A', '~', 195}, {'A', '"', 196}, {'A', '@', 197}, {'E', '`', 200}, {'E', '^', 202}, {'E', '"', 203}, {'I', '`', 204}, {'I', '^', 206}, {'I', '"', 207}, {'N', '~', 209}, {'O', '`', 210}, {'O', '^', 212}, {'O', '~', 213}, {'/', '\\', 215}, {'U', '`', 217}, {'U', '^', 219}, {'I', 'p', 222}, {'a', '`', 224}, {'a', '^', 226}, {'a', '~', 227}, {'a', '"', 228}, {'a', '@', 229}, {'e', '`', 232}, {'e', '^', 234}, {'e', '"', 235}, {'i', '`', 236}, {'i', '^', 238}, {'n', '~', 241}, {'o', '`', 242}, {'o', '^', 244}, {'o', '~', 245}, {'u', '`', 249}, {'u', '^', 251}, {'y', '"', 255}, {NUL, NUL, NUL}};
int WSInitialized = FALSE;
qf_info_T ql_info;
XtInputId inputHandler;
XtIntervalId timer = 0;
Widget menuBar = (Widget) 0;
Widget textArea = (Widget) 0;
proftime_T *nfa_time_limit;
char *e_auabort = N_ ("E855: Autocommands caused command to abort");
int expand_emenu;
vimmenu_T *expand_menu_alt = NULL;
vimmenu_T *expand_menu = NULL;
char_u e_nomenu [] = N_ ("E329: No menu \"%s\"");
char *tent;
TECObjectRef gUTF16ToUTF8Converter;
TECObjectRef gPathConverter;
HWND g_hWnd = NULL;
HANDLE g_hConOut = INVALID_HANDLE_VALUE;
HANDLE g_hConIn = INVALID_HANDLE_VALUE;
char *m_onlyone = N_ ("Already only one window");
proftime_T prof_wait_time;
int old_indent = 0;
char *e_letwrong = N_ ("E734: Wrong variable type for %s=");
char *e_letunexp = N_ ("E18: Unexpected characters in :let");
int already_warned = FALSE;
char *e_printf = N_ ("E766: Insufficient arguments for printf()");
BPTR raw_in = (BPTR) NULL;
char *e_nofold = N_ ("E490: No fold found");
int need_gather = FALSE;
ATSUStyle gFontStyle;
RgnHandle dragRgn;
char_u *reginput;
int regnzpar;
CurrentObject TheCurrent = {PyObject_HEAD_INIT (&CurrentType)};
float floatZero = 0.0;
EXTERN char_u e_readonlyvar [] INIT (= N_ ("E46: Cannot change read-only variable \"%s\""));
EXTERN char_u e_noroom [] INIT (= N_ ("E36: Not enough room"));
char *e_illvar = N_ ("E461: Illegal variable name: %s");
char *e_undefvar = N_ ("E121: Undefined variable: %s");
EXTERN char_u e_umark [] INIT (= N_ ("E78: Unknown mark"));
EXTERN long  p_window;
BOOL win8_or_later = FALSE;
foldinfo_T win_foldinfo;
struct Window *wb_window;
EventHandlerUPP winEventHandlerUPP = NULL;
EXTERN long  p_hi;
EXTERN char_u e_while [] INIT (= N_ ("E588: :endwhile without :while"));
RETSIGTYPE deathtrap SIGPROTOARG;
int prt_file_error;
EXTERN char_u *empty_option INIT (= (char_u *) "");
Frag_T empty;
EXTERN char_u *p_titleold;
EXTERN int p_title;
char_u *oldtitle = NULL;
char_u *oldwindowtitle = NULL;
int nfa_ll_index = 0;
int xt_index_in = 0;
PyObject *py_find_module;
int prt_duplex;
int needupdate = 0;
int g_fWindInitCalled = FALSE;
pumitem_T *balloon_array = NULL;
char_u e_z1_not_allowed [] = N_ ("E67: \\z1 et al. not allowed here");
char_u e_z_not_allowed [] = N_ ("E66: \\z( not allowed here");
EXTERN char_u e_openerrf [] INIT (= N_ ("E40: Can't open errorfile %s"));
char_u e_not_open [] = N_ ("E828: Cannot open undo file for writing: %s");
XtIntervalId blink_timer = (XtIntervalId) 0;
long_u blink_ontime = 400;
long_u blink_waittime = 700;
long_u blink_ontime = 400;
long_u blink_waittime = 700;
UINT blink_timer = 0;
long_u blink_ontime = 400;
long_u blink_waittime = 700;
EXTERN char_u e_invaddr [] INIT (= N_ ("E14: Invalid address"));
char *sysdrive;
TabListObject TheTabPageList = {PyObject_HEAD_INIT (&TabListType)};
WinListObject TheWindowList = {PyObject_HEAD_INIT (&WinListType) NULL
};
struct PyMethodDef CurrentMethods [] = {{"__dir__", (PyCFunction) CurrentDir, METH_NOARGS, ""}, {NULL, NULL, 0, NULL}};
char *CurrentAttrs [] = {"buffer", "window", "line", "range", "tabpage", NULL};
PyMappingMethods BufMapAsMapping = {(lenfunc) BufMapLength, (binaryfunc) BufMapItem, (objobjargproc) 0,};
struct PyMethodDef RangeMethods [] = {{"append", (PyCFunction) RangeAppend, METH_VARARGS, "Append data to the Vim range"}, {"__dir__", (PyCFunction) RangeDir, METH_NOARGS, ""}, {NULL, NULL, 0, NULL}};
char *RangeAttrs [] = {"start", "end", NULL};
struct PyMethodDef WindowMethods [] = {{"__dir__", (PyCFunction) WindowDir, METH_NOARGS, ""}, {NULL, NULL, 0, NULL}};
char *WindowAttrs [] = {"buffer", "cursor", "height", "vars", "options", "number", "row", "col", "tabpage", "valid", NULL};
struct PyMethodDef TabPageMethods [] = {{"__dir__", (PyCFunction) TabPageDir, METH_NOARGS, ""}, {NULL, NULL, 0, NULL}};
char *TabPageAttrs [] = {"windows", "number", "vars", "window", "valid", NULL};
PyMappingMethods OptionsAsMapping = {(lenfunc) NULL, (binaryfunc) OptionsItem, (objobjargproc) OptionsAssItem,};
PySequenceMethods OptionsAsSeq = {0, 0, 0, 0, 0, 0, 0, (objobjproc) OptionsContains, 0, 0,};
struct PyMethodDef ListMethods [] = {{"extend", (PyCFunction) ListConcatInPlace, METH_O, ""}, {"__dir__", (PyCFunction) ListDir, METH_NOARGS, ""}, {NULL, NULL, 0, NULL}};
PyMappingMethods ListAsMapping = {(lenfunc) ListLength, (binaryfunc) ListItem, (objobjargproc) ListAssItem,};
PySequenceMethods ListAsSeq = {(lenfunc) ListLength, (binaryfunc) 0, 0, (PyIntArgFunc) ListIndex, 0, (PyIntObjArgProc) ListAssIndex, 0, 0, (binaryfunc) ListConcatInPlace, 0,};
char *ListAttrs [] = {"locked", NULL};
struct PyMethodDef VimMethods [] = {{"command", VimCommand, METH_O, "Execute a Vim ex-mode command"}, {"eval", VimEval, METH_VARARGS, "Evaluate an expression using Vim evaluator"}, {"bindeval", VimEvalPy, METH_O, "Like eval(), but returns objects attached to vim ones"}, {"strwidth", VimStrwidth, METH_O, "Screen string width, counts <Tab> as having width 1"}, {"chdir", (PyCFunction) VimChdir, METH_VARARGS | METH_KEYWORDS, "Change directory"}, {"fchdir", (PyCFunction) VimFchdir, METH_VARARGS | METH_KEYWORDS, "Change directory"}, {"foreach_rtp", VimForeachRTP, METH_O, "Call given callable for each path in &rtp"}, {"find_module", FinderFindModule, METH_VARARGS, "Internal use only, returns loader object for any input it receives"}, {"path_hook", VimPathHook, METH_VARARGS, "Hook function to install in sys.path_hooks"}, {"_get_paths", (PyCFunction) Vim_GetPaths, METH_NOARGS, "Get &rtp-based additions to sys.path"}, {NULL, NULL, 0, NULL}};
struct PyMethodDef LoaderMethods [] = {{"load_module", (PyCFunction) LoaderLoadModule, METH_VARARGS, ""}, {NULL, NULL, 0, NULL}};
struct PyMethodDef OutputMethods [] = {{"write", (PyCFunction) OutputWrite, METH_O, ""}, {"writelines", (PyCFunction) OutputWritelines, METH_O, ""}, {"flush", (PyCFunction) AlwaysNone, METH_NOARGS, ""}, {"close", (PyCFunction) AlwaysNone, METH_NOARGS, ""}, {"isatty", (PyCFunction) AlwaysFalse, METH_NOARGS, ""}, {"readable", (PyCFunction) AlwaysFalse, METH_NOARGS, ""}, {"seekable", (PyCFunction) AlwaysFalse, METH_NOARGS, ""}, {"writable", (PyCFunction) AlwaysTrue, METH_NOARGS, ""}, {"closed", (PyCFunction) AlwaysFalse, METH_NOARGS, ""}, {"__dir__", (PyCFunction) OutputDir, METH_NOARGS, ""}, {NULL, NULL, 0, NULL}};
char *OutputAttrs [] = {"softspace", NULL};
PyObject *globals;
char_u e_py_systemexit [] = "E880: Can't handle SystemExit of %s exception in vim";
char ** (built_in_pixmaps []) = {tb_new_xpm, tb_open_xpm, tb_save_xpm, tb_undo_xpm, tb_redo_xpm, tb_cut_xpm, tb_copy_xpm, tb_paste_xpm, tb_print_xpm, tb_help_xpm, tb_find_xpm, tb_save_all_xpm, tb_save_session_xpm, tb_new_session_xpm, tb_load_session_xpm, tb_macro_xpm, tb_replace_xpm, tb_close_xpm, tb_maximize_xpm, tb_minimize_xpm, tb_split_xpm, tb_shell_xpm, tb_find_prev_xpm, tb_find_next_xpm, tb_find_help_xpm, tb_make_xpm, tb_jump_xpm, tb_ctags_xpm, tb_vsplit_xpm, tb_maxwidth_xpm, tb_minwidth_xpm, tb_exit_xpm};
EXTERN int p_ws;
EXTERN long  p_verbose;
EXTERN char_u *p_tbis;
EXTERN long  p_transp;
EXTERN char_u *p_tsr;
EXTERN int p_terse;
EXTERN int p_tgst;
EXTERN char_u *p_tags;
EXTERN int p_tbs;
EXTERN char_u *p_swb;
EXTERN char_u *p_sws;
EXTERN char_u *p_su;
EXTERN int p_sol;
EXTERN int p_spr;
EXTERN char_u *p_sps;
EXTERN int p_sb;
EXTERN int p_sta;
EXTERN long  p_siso;
EXTERN long  p_ss;
EXTERN int p_smd;
EXTERN int p_sm;
EXTERN int p_sft;
EXTERN char_u *p_sbr;
EXTERN char_u *p_shm;
EXTERN int p_sr;
EXTERN char_u *p_stl;
EXTERN char_u *p_srr;
EXTERN char_u *p_sxe;
EXTERN char_u *p_sxq;
EXTERN char_u *p_shq;
EXTERN char_u *p_sp;
EXTERN char_u *p_sh;
EXTERN char_u *p_ssop;
EXTERN char_u *p_slm;
EXTERN char_u *p_sel;
EXTERN char_u *p_sbo;
EXTERN long  p_so;
EXTERN long  p_sj;
EXTERN int p_paste;
EXTERN long  p_mouset;
EXTERN char_u *p_mousem;
EXTERN int p_mousef;
EXTERN char_u *p_mouse;
EXTERN long  p_mls;
EXTERN char_u *p_msm;
EXTERN long  p_mis;
EXTERN long  p_stal;
EXTERN long  p_ls;
EXTERN int p_js;
EXTERN char_u *p_isp;
EXTERN char_u *p_isi;
EXTERN char_u *p_isf;
EXTERN int p_is;
EXTERN int p_arshape;
EXTERN char_u *p_mouseshape;
EXTERN char_u *p_fuoptions;
EXTERN long  p_fdls;
EXTERN char_u *p_bsk;
EXTERN char_u *p_bs;
EXTERN char_u e_shellempty [] INIT (= N_ ("E91: 'shell' option is empty"));
EXTERN char_u e_listreq [] INIT (= N_ ("E714: List required"));
EXTERN char_u e_readonlysbx [] INIT (= N_ ("E794: Cannot set variable in the sandbox: \"%s\""));
EXTERN char_u e_noserver [] INIT (= N_ ("E247: no registered server named \"%s\""));
EXTERN char_u e_nopresub [] INIT (= N_ ("E33: No previous substitute regular expression"));
EXTERN char_u e_noinstext [] INIT (= N_ ("E29: No inserted text yet"));
EXTERN char_u e_nesting [] INIT (= N_ ("E22: Scripts nested too deep"));
EXTERN char_u e_marknotset [] INIT (= N_ ("E20: Mark not set"));
EXTERN char_u e_exists [] INIT (= N_ ("E13: File exists (add ! to override)"));
EXTERN char *netbeansArg INIT (= NULL);
EXTERN char_u *serverName INIT (= NULL);
EXTERN option_table_T printer_opts [OPT_PRINT_NUM_OPTIONS];
EXTERN long  sub_nsubs;
EXTERN alist_T global_alist;
EXTERN tabpage_T *first_tabpage;
EXTERN win_T *firstwin;
EXTERN char_u hash_removed;
EXTERN short  *TabPageIdxs INIT (= NULL);
EXTERN char_u *LineWraps INIT (= NULL);
EXTERN char_u farsi_text_5 [];
EXTERN char_u farsi_text_3 [];
EXTERN char_u farsi_text_2 [];
EXTERN char_u farsi_text_1 [];
SPELL_EXTERN spelltab_T spelltab;
SPELL_EXTERN char_u *int_wordlist SPELL_INIT (= NULL);
SPELL_EXTERN slang_T *first_lang SPELL_INIT (= NULL);
struct prt_resfile_buffer_S prt_resfile;
FILE *prt_ps_fd;
char osver [] = "";
char version [] = "xxd V1.10 27oct98 by Juergen Weigert";
char * (main_errors []) = {N_ ("Unknown option argument"), 
    #define ME_UNKNOWN_OPTION	0
    N_ ("Too many edit arguments"), 
    #define ME_TOO_MANY_ARGS	1
    N_ ("Argument missing after"), 
    #define ME_ARG_MISSING		2
    N_ ("Garbage after option argument"), 
    #define ME_GARBAGE		3
    N_ ("Too many \"+command\", \"-c command\" or \"--cmd command\" arguments"), 
    #define ME_EXTRA_CMD		4
    N_ ("Invalid argument for"), 
    #define ME_INVALID_ARG		5

};
xfmark_T *vi_jumplist = NULL;
int dialogStatus;
garray_T user_digraphs = {0, 0, (int) sizeof (digr_T), 10, NULL};
const LOGFONT s_lfDefault = {-12, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE, DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, PROOF_QUALITY, FIXED_PITCH | FF_DONTCARE, "Fixedsys"};
struct quality_pair quality_pairs [] = {{"DEFAULT", DEFAULT_QUALITY}, {NULL, 0}};
garray_T reply_list = {0, 0, sizeof (reply_T), 5, 0};
HWND message_window = 0;
int undo_undoes = FALSE;
int is_ignore_draw = FALSE;
PhPoint_t abs_mouse;
Boolean save_files = True;
int sd = -1;
char defaultTranslations [] = "<Btn1Down>: NotifyScroll()\n\
     <Btn2Down>: MoveThumb() NotifyThumb()\n\
     <Btn3Down>: NotifyScroll()\n\
     <Btn4Down>: ScrollOneLineUp()\n\
     Shift<Btn4Down>: ScrollPageUp()\n\
     <Btn5Down>: ScrollOneLineDown()\n\
     Shift<Btn5Down>: ScrollPageDown()\n\
     <Btn1Motion>: HandleThumb()\n\
     <Btn3Motion>: HandleThumb()\n\
     <Btn2Motion>: MoveThumb() NotifyThumb()\n\
     <BtnUp>: EndScroll()";
int dialogStatus;
XtTranslations menuTrans;
XtTranslations parentTrans;
XtTranslations popupTrans;
char_u sha256_padding [64] = {0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
yankreg_T *y_read_regs = NULL;
yankreg_T y_regs [NUM_REGISTERS];
sortinfo_T *sortinfo = NULL;
garray_T ga_userinput = {0, 0, sizeof (tasave_T), 4, NULL};
int save_level = 0;
VTermColor ansi_table [16] = {{0, 0, 0, 1}, {224, 0, 0, 2}, {0, 224, 0, 3}, {224, 224, 0, 4}, {0, 0, 224, 5}, {224, 0, 224, 6}, {0, 224, 224, 7}, {224, 224, 224, 8}, {128, 128, 128, 9}, {255, 64, 64, 10}, {64, 255, 64, 11}, {255, 255, 64, 12}, {64, 64, 255, 13}, {255, 64, 255, 14}, {64, 255, 255, 15}, {255, 255, 255, 16},};
int expand_isabbrev = 0;
mapblock_T *first_abbr = NULL;
mapblock_T * (maphash [256]);
garray_T menutrans_ga = {0, 0, 0, 0, NULL};
char_u e_notsubmenu [] = N_ ("E327: Part of menu-item path is not sub-menu");
long  _bauds [16] = {0, 50, 75, 110, 134, 150, 200, 300, 600, 1200, 1800, 2400, 4800, 9600, 19200, 19200};
short  ospeed;
char_u *old_sub = NULL;
int sort_abort;
int sort_flt;
int sort_rx;
int sort_nr;
int s_usenewlook;
void TrackUserActivity (UINT uMsg);
UINT s_wait_timer = 0;
char_u *s_textfield;
UINT s_uMsg = 0;
HWND s_textArea = NULL;
LPARAM s_lParam = 0;
WPARAM s_wParam = 0;
HBRUSH s_brush = NULL;
HINSTANCE s_hinst = NULL;
int destroying = FALSE;
HMENU s_menuBar = NULL;
int ex_pressedreturn = FALSE;
char g_szOrigTitle [256] = {0};
int g_yMouse;
int g_xMouse;
int g_fMouseAvail = FALSE;
int g_fCtrlCPressed = FALSE;
int g_fCBrkPressed = FALSE;
proftime_T pause_time;
timer_T *first_timer = NULL;
int debug_skipped;
job_T *first_job = NULL;
list_T *first_list = NULL;
int ins_need_undo;
int revins_legal;
int revins_on;
int new_insert_skip;
dictitem_T vimvars_var;
struct vimvar vimvars [VV_LEN] = {{VV_NAME ("count", VAR_NUMBER), VV_COMPAT + VV_RO}, {VV_NAME ("count1", VAR_NUMBER), VV_RO}, {VV_NAME ("prevcount", VAR_NUMBER), VV_RO}, {VV_NAME ("errmsg", VAR_STRING), VV_COMPAT}, {VV_NAME ("warningmsg", VAR_STRING), 0}, {VV_NAME ("statusmsg", VAR_STRING), 0}, {VV_NAME ("shell_error", VAR_NUMBER), VV_COMPAT + VV_RO}, {VV_NAME ("this_session", VAR_STRING), VV_COMPAT}, {VV_NAME ("version", VAR_NUMBER), VV_COMPAT + VV_RO}, {VV_NAME ("lnum", VAR_NUMBER), VV_RO_SBX}, {VV_NAME ("termresponse", VAR_STRING), VV_RO}, {VV_NAME ("fname", VAR_STRING), VV_RO}, {VV_NAME ("lang", VAR_STRING), VV_RO}, {VV_NAME ("lc_time", VAR_STRING), VV_RO}, {VV_NAME ("ctype", VAR_STRING), VV_RO}, {VV_NAME ("charconvert_from", VAR_STRING), VV_RO}, {VV_NAME ("charconvert_to", VAR_STRING), VV_RO}, {VV_NAME ("fname_in", VAR_STRING), VV_RO}, {VV_NAME ("fname_out", VAR_STRING), VV_RO}, {VV_NAME ("fname_new", VAR_STRING), VV_RO}, {VV_NAME ("fname_diff", VAR_STRING), VV_RO}, {VV_NAME ("cmdarg", VAR_STRING), VV_RO}, {VV_NAME ("foldstart", VAR_NUMBER), VV_RO_SBX}, {VV_NAME ("foldend", VAR_NUMBER), VV_RO_SBX}, {VV_NAME ("folddashes", VAR_STRING), VV_RO_SBX}, {VV_NAME ("foldlevel", VAR_NUMBER), VV_RO_SBX}, {VV_NAME ("progname", VAR_STRING), VV_RO}, {VV_NAME ("servername", VAR_STRING), VV_RO}, {VV_NAME ("dying", VAR_NUMBER), VV_RO}, {VV_NAME ("exception", VAR_STRING), VV_RO}, {VV_NAME ("throwpoint", VAR_STRING), VV_RO}, {VV_NAME ("register", VAR_STRING), VV_RO}, {VV_NAME ("cmdbang", VAR_NUMBER), VV_RO}, {VV_NAME ("insertmode", VAR_STRING), VV_RO}, {VV_NAME ("val", VAR_UNKNOWN), VV_RO}, {VV_NAME ("key", VAR_UNKNOWN), VV_RO}, {VV_NAME ("profiling", VAR_NUMBER), VV_RO}, {VV_NAME ("fcs_reason", VAR_STRING), VV_RO}, {VV_NAME ("fcs_choice", VAR_STRING), 0}, {VV_NAME ("beval_bufnr", VAR_NUMBER), VV_RO}, {VV_NAME ("beval_winnr", VAR_NUMBER), VV_RO}, {VV_NAME ("beval_winid", VAR_NUMBER), VV_RO}, {VV_NAME ("beval_lnum", VAR_NUMBER), VV_RO}, {VV_NAME ("beval_col", VAR_NUMBER), VV_RO}, {VV_NAME ("beval_text", VAR_STRING), VV_RO}, {VV_NAME ("scrollstart", VAR_STRING), 0}, {VV_NAME ("swapname", VAR_STRING), VV_RO}, {VV_NAME ("swapchoice", VAR_STRING), 0}, {VV_NAME ("swapcommand", VAR_STRING), VV_RO}, {VV_NAME ("char", VAR_STRING), 0}, {VV_NAME ("mouse_win", VAR_NUMBER), 0}, {VV_NAME ("mouse_winid", VAR_NUMBER), 0}, {VV_NAME ("mouse_lnum", VAR_NUMBER), 0}, {VV_NAME ("mouse_col", VAR_NUMBER), 0}, {VV_NAME ("operator", VAR_STRING), VV_RO}, {VV_NAME ("searchforward", VAR_NUMBER), 0}, {VV_NAME ("hlsearch", VAR_NUMBER), 0}, {VV_NAME ("oldfiles", VAR_LIST), 0}, {VV_NAME ("windowid", VAR_NUMBER), VV_RO}, {VV_NAME ("progpath", VAR_STRING), VV_RO}, {VV_NAME ("completed_item", VAR_DICT), VV_RO}, {VV_NAME ("option_new", VAR_STRING), VV_RO}, {VV_NAME ("option_old", VAR_STRING), VV_RO}, {VV_NAME ("option_type", VAR_STRING), VV_RO}, {VV_NAME ("errors", VAR_LIST), 0}, {VV_NAME ("false", VAR_SPECIAL), VV_RO}, {VV_NAME ("true", VAR_SPECIAL), VV_RO}, {VV_NAME ("null", VAR_SPECIAL), VV_RO}, {VV_NAME ("none", VAR_SPECIAL), VV_RO}, {VV_NAME ("vim_did_enter", VAR_NUMBER), VV_RO}, {VV_NAME ("testing", VAR_NUMBER), 0}, {VV_NAME ("t_number", VAR_NUMBER), VV_RO}, {VV_NAME ("t_string", VAR_NUMBER), VV_RO}, {VV_NAME ("t_func", VAR_NUMBER), VV_RO}, {VV_NAME ("t_list", VAR_NUMBER), VV_RO}, {VV_NAME ("t_dict", VAR_NUMBER), VV_RO}, {VV_NAME ("t_float", VAR_NUMBER), VV_RO}, {VV_NAME ("t_bool", VAR_NUMBER), VV_RO}, {VV_NAME ("t_none", VAR_NUMBER), VV_RO}, {VV_NAME ("t_job", VAR_NUMBER), VV_RO}, {VV_NAME ("t_channel", VAR_NUMBER), VV_RO}, {VV_NAME ("termrfgresp", VAR_STRING), VV_RO}, {VV_NAME ("termrbgresp", VAR_STRING), VV_RO}, {VV_NAME ("termu7resp", VAR_STRING), VV_RO}, {VV_NAME ("termstyleresp", VAR_STRING), VV_RO}, {VV_NAME ("termblinkresp", VAR_STRING), VV_RO}, {VV_NAME ("event", VAR_DICT), VV_RO},};
dictitem_T globvars_var;
garray_T ignore_error_list = GA_EMPTY;
FILE *verbose_fd = NULL;
struct IntuitionBase *IntuitionBase = NULL;
linenr_T lowest_marked = 0;
int pum_first = 0;
int disable_flush = 0;
short  *gDialogHotKeys;
char_u *ta_str = NULL;
garray_T ga_users;
regsubmatch_T rsm;
int re_has_z;
char_u e_empty_sb [] = N_ ("E70: Empty %s%%[]");
char_u e_missing_sb [] = N_ ("E69: Missing ] after %s%%[");
char_u e_reverse_range [] = N_ ("E944: Reverse range in character class");
void _cdecl SaveInst (HINSTANCE hInst);
struct mousetable mouse_table [] = {{(int) KE_LEFTMOUSE, MOUSE_LEFT, TRUE, FALSE}, {(int) KE_LEFTMOUSE_NM, MOUSE_LEFT, TRUE, FALSE}, {(int) KE_LEFTDRAG, MOUSE_LEFT, FALSE, TRUE}, {(int) KE_LEFTRELEASE, MOUSE_LEFT, FALSE, FALSE}, {(int) KE_LEFTRELEASE_NM, MOUSE_LEFT, FALSE, FALSE}, {(int) KE_MIDDLEMOUSE, MOUSE_MIDDLE, TRUE, FALSE}, {(int) KE_MIDDLEDRAG, MOUSE_MIDDLE, FALSE, TRUE}, {(int) KE_MIDDLERELEASE, MOUSE_MIDDLE, FALSE, FALSE}, {(int) KE_RIGHTMOUSE, MOUSE_RIGHT, TRUE, FALSE}, {(int) KE_RIGHTDRAG, MOUSE_RIGHT, FALSE, TRUE}, {(int) KE_RIGHTRELEASE, MOUSE_RIGHT, FALSE, FALSE}, {(int) KE_X1MOUSE, MOUSE_X1, TRUE, FALSE}, {(int) KE_X1DRAG, MOUSE_X1, FALSE, TRUE}, {(int) KE_X1RELEASE, MOUSE_X1, FALSE, FALSE}, {(int) KE_X2MOUSE, MOUSE_X2, TRUE, FALSE}, {(int) KE_X2DRAG, MOUSE_X2, FALSE, TRUE}, {(int) KE_X2RELEASE, MOUSE_X2, FALSE, FALSE}, {(int) KE_MOUSEMOVE, MOUSE_RELEASE, FALSE, TRUE}, {(int) KE_IGNORE, MOUSE_RELEASE, FALSE, FALSE}, {0, 0, 0, 0},};
sftword_T dumsft;
int sps_limit = 9999;
sign_T *first_sign = NULL;
struct signalinfo signal_info [] = {{-1, "Unknown!", FALSE}};
volatile int deadly_signal = 0;
char_u e_nul_found [] = N_ ("E865: (NFA) Regexp end encountered prematurely");
struct modmasktable mod_mask_table [] = {{MOD_MASK_ALT, MOD_MASK_ALT, (char_u) 'M'}, {MOD_MASK_META, MOD_MASK_META, (char_u) 'T'}, {MOD_MASK_CTRL, MOD_MASK_CTRL, (char_u) 'C'}, {MOD_MASK_SHIFT, MOD_MASK_SHIFT, (char_u) 'S'}, {MOD_MASK_MULTI_CLICK, MOD_MASK_2CLICK, (char_u) '2'}, {MOD_MASK_MULTI_CLICK, MOD_MASK_3CLICK, (char_u) '3'}, {MOD_MASK_MULTI_CLICK, MOD_MASK_4CLICK, (char_u) '4'}, {MOD_MASK_CMD, MOD_MASK_CMD, (char_u) 'D'}, {MOD_MASK_ALT, MOD_MASK_ALT, (char_u) 'A'}, {0, 0, NUL}};
int old_mod_mask;
EXTERN int p_guipty;
int prt_font;
int prt_need_font;
struct prt_ps_font_S *prt_ps_font;
PtWidget_t *gui_ph_dialog_text = NULL;
PtCallbackF_t gui_ph_handle_menu_unrealized;
PtCallbackF_t gui_ph_handle_menu;
PtCallbackF_t gui_ph_handle_pulldown_menu;
PtCallbackF_t gui_ph_handle_mouse;
LOGFONT sub_logfont;
EXTERN char_u *p_toolbar;
EXTERN int p_to;
EXTERN char_u e_toomany [] INIT (= N_ ("E77: Too many file names"));
EXTERN char_u e_toomsbra [] INIT (= N_ ("E76: Too many ["));
int prt_do_moveto;
int prt_need_moveto;
int ramp24 [] = {0x08, 0x12, 0x1C, 0x26, 0x30, 0x3A, 0x44, 0x4E, 0x58, 0x62, 0x6C, 0x76, 0x81, 0x8A, 0x94, 0x9E, 0xA8, 0xB2, 0xBC, 0xC6, 0xD0, 0xDA, 0xE4, 0xEE,};
Atom wm_atoms [2];
unsigned  char etoa64 [] = {0040, 0240, 0241, 0242, 0243, 0244, 0245, 0246, 0247, 0250, 0325, 0056, 0074, 0050, 0053, 0174, 0046, 0251, 0252, 0253, 0254, 0255, 0256, 0257, 0260, 0261, 0041, 0044, 0052, 0051, 0073, 0176, 0055, 0057, 0262, 0263, 0264, 0265, 0266, 0267, 0270, 0271, 0313, 0054, 0045, 0137, 0076, 0077, 0272, 0273, 0274, 0275, 0276, 0277, 0300, 0301, 0302, 0140, 0072, 0043, 0100, 0047, 0075, 0042, 0303, 0141, 0142, 0143, 0144, 0145, 0146, 0147, 0150, 0151, 0304, 0305, 0306, 0307, 0310, 0311, 0312, 0152, 0153, 0154, 0155, 0156, 0157, 0160, 0161, 0162, 0136, 0314, 0315, 0316, 0317, 0320, 0321, 0345, 0163, 0164, 0165, 0166, 0167, 0170, 0171, 0172, 0322, 0323, 0324, 0133, 0326, 0327, 0330, 0331, 0332, 0333, 0334, 0335, 0336, 0337, 0340, 0341, 0342, 0343, 0344, 0135, 0346, 0347, 0173, 0101, 0102, 0103, 0104, 0105, 0106, 0107, 0110, 0111, 0350, 0351, 0352, 0353, 0354, 0355, 0175, 0112, 0113, 0114, 0115, 0116, 0117, 0120, 0121, 0122, 0356, 0357, 0360, 0361, 0362, 0363, 0134, 0237, 0123, 0124, 0125, 0126, 0127, 0130, 0131, 0132, 0364, 0365, 0366, 0367, 0370, 0371, 0060, 0061, 0062, 0063, 0064, 0065, 0066, 0067, 0070, 0071, 0372, 0373, 0374, 0375, 0376, 0377};
Widget toolBar;
Widget toolBarFrame;
PhImage_t *gui_ph_toolbar_images [] = {&tb_new_phi, &tb_open_phi, &tb_save_phi, &tb_undo_phi, &tb_redo_phi, &tb_cut_phi, &tb_copy_phi, &tb_paste_phi, &tb_print_phi, &tb_help_phi, &tb_find_phi, &tb_save_all_phi, &tb_save_session_phi, &tb_new_session_phi, &tb_load_session_phi, &tb_macro_phi, &tb_replace_phi, &tb_close_phi, &tb_maximize_phi, &tb_minimize_phi, &tb_split_phi, &tb_shell_phi, &tb_find_prev_phi, &tb_find_next_phi, &tb_find_help_phi, &tb_make_phi, &tb_jump_phi, &tb_ctags_phi, &tb_vsplit_phi, &tb_maxwidth_phi, &tb_minwidth_phi};
Atom dialogatom;
Widget toolBar = (Widget) 0;
int dialog_default_button = -1;
char_u *reg_tofree = NULL;
int reg_toolong;
char_u *repl_to = NULL;
char_u *repl_from = NULL;
EXTERN char_u e_toomanyarg [] INIT (= N_ ("E118: Too many arguments for function: %s"));
EXTERN char_u e_invarg2 [] INIT (= N_ ("E475: Invalid argument: %s"));
EXTERN char_u e_invarg [] INIT (= N_ ("E474: Invalid argument"));
EXTERN char_u e_argreq [] INIT (= N_ ("E471: Argument required"));
EXTERN char_u *edit_submode_extra INIT (= NULL);
EXTERN char_u *edit_submode_pre INIT (= NULL);
EXTERN char_u *edit_submode INIT (= NULL);
float prt_bottom_margin;
float prt_right_margin;
float prt_left_margin;
int VIsual_mode_orig = NUL;
int resel_VIsual_mode = NUL;
char *e_listarg = N_ ("E686: Argument of %s must be a List");
int expand_mapmodes = 0;
int expand_modes = 0x0;
char_u *extra_shell_arg = NULL;
EXTERN struct msglist **msg_list INIT (= NULL);
EXTERN char_u *keep_msg INIT (= NULL);
char_u *bottommsg = (char_u *) N_ ("E555: at bottom of tag stack");
char *sha_self_test_msg [] = {"abc", "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq", NULL};
char *msg_qflist = N_ ("[Quickfix List]");
struct msg_hist *first_msg_hist = NULL;
EXTERN char_u *p_header;
HWND vim_parent_hwnd = NULL;
HWND s_toolbarhwnd = NULL;
HWND s_hwnd = NULL;
void _OnPaint (HWND hwnd);
int interactive;
struct object_constant object_constants [] = {{"buffers", (PyObject *) (void *) &TheBufferMap}, {"windows", (PyObject *) (void *) &TheWindowList}, {"tabpages", (PyObject *) (void *) &TheTabPageList}, {"current", (PyObject *) (void *) &TheCurrent}, {"Buffer", (PyObject *) &BufferType}, {"Range", (PyObject *) &RangeType}, {"Window", (PyObject *) &WindowType}, {"TabPage", (PyObject *) &TabPageType}, {"Dictionary", (PyObject *) &DictionaryType}, {"List", (PyObject *) &ListType}, {"Function", (PyObject *) &FunctionType}, {"Options", (PyObject *) &OptionsType}, {"_Loader", (PyObject *) &LoaderType},};
struct numeric_constant numeric_constants [] = {{"VAR_LOCKED", VAR_LOCKED}, {"VAR_FIXED", VAR_FIXED}, {"VAR_SCOPE", VAR_SCOPE}, {"VAR_DEF_SCOPE", VAR_DEF_SCOPE},};
PyObject * WinListNew (TabPageObject *tabObject);
struct PyMethodDef FunctionMethods [] = {{"__dir__", (PyCFunction) FunctionDir, METH_NOARGS, ""}, {NULL, NULL, 0, NULL}};
char *FunctionAttrs [] = {"softspace", "args", "self", "auto_rebind", NULL};
struct PyMethodDef DictionaryMethods [] = {{"keys", (PyCFunction) DictionaryListKeys, METH_NOARGS, ""}, {"values", (PyCFunction) DictionaryListValues, METH_NOARGS, ""}, {"items", (PyCFunction) DictionaryListItems, METH_NOARGS, ""}, {"update", (PyCFunction) DictionaryUpdate, METH_VARARGS | METH_KEYWORDS, ""}, {"get", (PyCFunction) DictionaryGet, METH_VARARGS, ""}, {"pop", (PyCFunction) DictionaryPop, METH_VARARGS, ""}, {"popitem", (PyCFunction) DictionaryPopItem, METH_NOARGS, ""}, {"has_key", (PyCFunction) DictionaryHasKey, METH_O, ""}, {"__dir__", (PyCFunction) DictionaryDir, METH_NOARGS, ""}, {NULL, NULL, 0, NULL}};
PyMappingMethods DictionaryAsMapping = {(lenfunc) DictionaryLength, (binaryfunc) DictionaryItem, (objobjargproc) DictionaryAssItem,};
PySequenceMethods DictionaryAsSeq = {0, 0, 0, 0, 0, 0, 0, (objobjproc) DictionaryContains, 0, 0,};
char *DictionaryAttrs [] = {"locked", "scope", NULL};
PyObject *py_getcwd;
EXTERN long  p_wic;
EXTERN long  p_wcm;
EXTERN long  p_wc;
EXTERN char_u *p_fcs;
EXTERN long  p_uc;
EXTERN long  p_ttyscroll;
EXTERN int p_ttimeout;
EXTERN int p_timeout;
EXTERN int p_tgc;
EXTERN char_u *p_tc;
EXTERN int p_scs;
EXTERN int p_sc;
EXTERN char_u *p_shcf;
EXTERN char_u *p_sections;
EXTERN char_u *p_opfunc;
EXTERN char_u *p_cc;
EXTERN char_u *p_scl;
EXTERN int p_magic;
EXTERN int p_macthinstrokes;
EXTERN int p_macligatures;
EXTERN char_u *p_lcs;
EXTERN int p_ic;
EXTERN int p_icon;
EXTERN char_u *p_penc;
EXTERN int p_fullscreen;
EXTERN char_u *p_fcl;
EXTERN long  p_fic;
EXTERN char_u *p_dict;
EXTERN char_u *p_inc;
EXTERN char_u *p_cpo;
EXTERN char_u *p_cot;
EXTERN int p_cp;
EXTERN long  p_ch;
EXTERN int p_beval;
EXTERN char_u *p_cm;
EXTERN char_u *p_bkc;
EXTERN int p_acd;
EXTERN int *eval_lavars_used INIT (= NULL);
EXTERN char_u e_toocompl [] INIT (= N_ ("E74: Command too complex"));
EXTERN char_u e_tagstack [] INIT (= N_ ("E73: tag stack empty"));
EXTERN char_u e_swapclose [] INIT (= N_ ("E72: Close error on swap file"));
EXTERN char_u e_scroll [] INIT (= N_ ("E49: Invalid scroll size"));
EXTERN char_u e_screenmode [] INIT (= N_ ("E359: Screen mode setting not supported"));
EXTERN char_u e_listdictarg [] INIT (= N_ ("E712: Argument of %s must be a List or Dictionary"));
EXTERN char_u e_dictreq [] INIT (= N_ ("E715: Dictionary required"));
EXTERN char_u e_re_corr [] INIT (= N_ ("E44: Corrupted regexp program"));
EXTERN char_u e_loclist [] INIT (= N_ ("E776: No location list"));
EXTERN char_u e_quickfix [] INIT (= N_ ("E42: No Errors"));
EXTERN char_u e_outofmem [] INIT (= N_ ("E41: Out of memory!"));
EXTERN char_u e_notcreate [] INIT (= N_ ("E482: Can't create file %s"));
EXTERN char_u e_markinval [] INIT (= N_ ("E19: Mark has invalid line number"));
EXTERN char_u e_invargNval [] INIT (= N_ ("E475: Invalid value for argument %s: %s"));
EXTERN char_u e_backslash [] INIT (= N_ ("E10: \\ should be followed by /, ? or &"));
EXTERN char_u langmap_mapchar [256];
EXTERN char_u *escape_chars INIT (= (char_u *) " \t\\\"|");
EXTERN FILE *scriptout INIT (= NULL);
EXTERN FILE *scriptin [NSCRIPT];
EXTERN cmdmod_T cmdmod;
EXTERN win_T *aucmd_win;
EXTERN int called_emsg;
EXTERN int called_vim_beep;
EXTERN dict_T globvardict;
EXTERN dict_T vimvardict;
EXTERN sattr_T *ScreenAttrs INIT (= NULL);
EXTERN schar_T *ScreenLines INIT (= NULL);
void DWriteContext_Close (DWriteContext *ctx);
void DWriteContext_Flush (DWriteContext *ctx);
VTermScreenCallbacks screen_cbs = {screen_damage, moverect, movecursor, settermprop, NULL, NULL, screen_sb_pushline, screen_sb_popline};
int want_screen_scrollback = 0;
int want_screen_damage_cells = 0;
int want_screen_damage = 0;
int want_moverect = 0;
int want_scrollrect = 0;
VTermParserCallbacks parser_cbs = {parser_text, parser_control, parser_escape, parser_csi, parser_osc, parser_dcs, NULL};
VTermEncodingInstance encoding;
VTermScreen *screen;
int prt_num_copies;
struct prt_dsc_comment_S prt_dsc_table [] = {{PRT_DSC_TITLE, SIZEOF_CSTR (PRT_DSC_TITLE), PRT_DSC_TITLE_TYPE}, {PRT_DSC_VERSION, SIZEOF_CSTR (PRT_DSC_VERSION), PRT_DSC_VERSION_TYPE}, {PRT_DSC_ENDCOMMENTS, SIZEOF_CSTR (PRT_DSC_ENDCOMMENTS), PRT_DSC_ENDCOMMENTS_TYPE}};
struct prt_ps_font_S prt_ps_courier_font = {600, -100, 50, -250, 805, {"Courier", "Courier-Bold", "Courier-Oblique", "Courier-BoldOblique"}};
VTermEncoding encoding_usascii = {NULL, &decode_usascii};
VTermEncoding encoding_utf8 = {&init_utf8, &decode_utf8};
XtResource vim_resources [] = {{XtNforeground, XtCForeground, XtRPixel, sizeof (Pixel), XtOffsetOf (gui_T, def_norm_pixel), XtRString, XtDefaultForeground}, {XtNbackground, XtCBackground, XtRPixel, sizeof (Pixel), XtOffsetOf (gui_T, def_back_pixel), XtRString, XtDefaultBackground}, {XtNfont, XtCFont, XtRString, sizeof (String *), XtOffsetOf (gui_T, rsrc_font_name), XtRImmediate, XtDefaultFont}, {XtNboldFont, XtCBoldFont, XtRString, sizeof (String *), XtOffsetOf (gui_T, rsrc_bold_font_name), XtRImmediate, ""}, {XtNitalicFont, XtCItalicFont, XtRString, sizeof (String *), XtOffsetOf (gui_T, rsrc_ital_font_name), XtRImmediate, ""}, {XtNboldItalicFont, XtCBoldItalicFont, XtRString, sizeof (String *), XtOffsetOf (gui_T, rsrc_boldital_font_name), XtRImmediate, ""}, {XtNgeometry, XtCGeometry, XtRString, sizeof (String *), XtOffsetOf (gui_T, geom), XtRImmediate, ""}, {XtNreverseVideo, XtCReverseVideo, XtRBool, sizeof (Bool), XtOffsetOf (gui_T, rsrc_rev_video), XtRImmediate, (XtPointer) False}, {XtNborderWidth, XtCBorderWidth, XtRInt, sizeof (int), XtOffsetOf (gui_T, border_width), XtRImmediate, (XtPointer) 2}, {XtNscrollbarWidth, XtCScrollbarWidth, XtRInt, sizeof (int), XtOffsetOf (gui_T, scrollbar_width), XtRImmediate, (XtPointer) SB_DEFAULT_WIDTH}, {XtNmenuFont, XtCMenuFont, XtRString, sizeof (char *), XtOffsetOf (gui_T, rsrc_menu_font_name), XtRString, DFLT_MENU_FONT}, {XtNmenuForeground, XtCMenuForeground, XtRString, sizeof (char *), XtOffsetOf (gui_T, rsrc_menu_fg_name), XtRString, DFLT_MENU_FG_COLOR}, {XtNmenuBackground, XtCMenuBackground, XtRString, sizeof (char *), XtOffsetOf (gui_T, rsrc_menu_bg_name), XtRString, DFLT_MENU_BG_COLOR}, {XtNscrollForeground, XtCScrollForeground, XtRString, sizeof (char *), XtOffsetOf (gui_T, rsrc_scroll_fg_name), XtRString, DFLT_SCROLL_FG_COLOR}, {XtNscrollBackground, XtCScrollBackground, XtRString, sizeof (char *), XtOffsetOf (gui_T, rsrc_scroll_bg_name), XtRString, DFLT_SCROLL_BG_COLOR}, {XtNtooltipForeground, XtCTooltipForeground, XtRString, sizeof (char *), XtOffsetOf (gui_T, rsrc_tooltip_fg_name), XtRString, DFLT_TOOLTIP_FG_COLOR}, {XtNtooltipBackground, XtCTooltipBackground, XtRString, sizeof (char *), XtOffsetOf (gui_T, rsrc_tooltip_bg_name), XtRString, DFLT_TOOLTIP_BG_COLOR}, {XtNtooltipFont, XtCTooltipFont, XtRString, sizeof (char *), XtOffsetOf (gui_T, rsrc_tooltip_font_name), XtRString, DFLT_TOOLTIP_FONT}, {"balloonEvalFontSet", XtCFontSet, XtRFontSet, sizeof (XFontSet), XtOffsetOf (gui_T, tooltip_fontset), XtRImmediate, (XtPointer) NOFONTSET},};
long  compress_added = 500000;
long  compress_inc = 100;
char *msg_compressing = N_ ("Compressing word tree...");
char *e_spell_trunc = N_ ("E758: Truncated spell file");
int has_dash_c_arg = FALSE;
int A_is_special (int c);
int A_is_valid (int c);
int A_is_ok (int c);
int A_is_formb (int c);
int A_is_iso (int c);
int A_is_harakat (int c);
const VTermParserCallbacks parser_callbacks = {on_text, on_control, on_escape, on_csi, on_osc, on_dcs, on_resize};
VTermAllocatorFunctions default_allocator = {&default_malloc, &default_free};
VALUE cVimWindow;
struct charset_pair charset_pairs [] = {{"ANSI", ANSI_CHARSET}, {"CHINESEBIG5", CHINESEBIG5_CHARSET}, {"DEFAULT", DEFAULT_CHARSET}, {"HANGEUL", HANGEUL_CHARSET}, {"OEM", OEM_CHARSET}, {"SHIFTJIS", SHIFTJIS_CHARSET}, {"SYMBOL", SYMBOL_CHARSET}, {"ARABIC", ARABIC_CHARSET}, {"BALTIC", BALTIC_CHARSET}, {"EASTEUROPE", EASTEUROPE_CHARSET}, {"GB2312", GB2312_CHARSET}, {"GREEK", GREEK_CHARSET}, {"HEBREW", HEBREW_CHARSET}, {"JOHAB", JOHAB_CHARSET}, {"MAC", MAC_CHARSET}, {"RUSSIAN", RUSSIAN_CHARSET}, {"THAI", THAI_CHARSET}, {"TURKISH", TURKISH_CHARSET}, {NULL, 0}};
int reply_received = 0;
char_u *client_enc = NULL;
char *e_loc_list_changed = N_ ("E926: Current location list was changed");
PtCallbackF_t gui_ph_handle_focus;
PtCallbackF_t gui_ph_handle_scrollbar;
PtCallbackF_t gui_ph_handle_window_cb;
PtCallbackF_t gui_ph_handle_timer_timeout;
struct PxTransCtrl *charset_translate;
short  is_timeout;
PtWidget_t *gui_ph_timer_timeout;
ScrollbarClassRec vim_scrollbarClassRec = {{(WidgetClass) &simpleClassRec, "Scrollbar", sizeof (ScrollbarRec), ClassInitialize, NULL, FALSE, Initialize, NULL, Realize, actions, XtNumber (actions), resources, XtNumber (resources), NULLQUARK, TRUE, TRUE, TRUE, FALSE, Destroy, Resize, Redisplay, SetValues, NULL, XtInheritSetValuesAlmost, NULL, NULL, XtVersion, NULL, defaultTranslations, XtInheritQueryGeometry, XtInheritDisplayAccelerator, NULL}, {XtInheritChangeSensitive, NULL}, {0}};
XtActionsRec actions [] = {{"HandleThumb", HandleThumb}, {"MoveThumb", MoveThumb}, {"NotifyThumb", NotifyThumb}, {"NotifyScroll", NotifyScroll}, {"EndScroll", EndScroll}, {"ScrollOneLineUp", ScrollOneLineUp}, {"ScrollOneLineDown", ScrollOneLineDown}, {"ScrollPageUp", ScrollPageUp}, {"ScrollPageDown", ScrollPageDown}};
XtResource resources [] = {{XtNlength, XtCLength, XtRDimension, sizeof (Dimension), Offset (scrollbar.length), XtRImmediate, (XtPointer) 1}, {XtNthickness, XtCThickness, XtRDimension, sizeof (Dimension), Offset (scrollbar.thickness), XtRImmediate, (XtPointer) 14}, {XtNorientation, XtCOrientation, XtROrientation, sizeof (XtOrientation), Offset (scrollbar.orientation), XtRImmediate, (XtPointer) XtorientVertical}, {XtNscrollProc, XtCCallback, XtRCallback, sizeof (XtPointer), Offset (scrollbar.scrollProc), XtRCallback, NULL}, {XtNthumbProc, XtCCallback, XtRCallback, sizeof (XtPointer), Offset (scrollbar.thumbProc), XtRCallback, NULL}, {XtNjumpProc, XtCCallback, XtRCallback, sizeof (XtPointer), Offset (scrollbar.jumpProc), XtRCallback, NULL}, {XtNthumb, XtCThumb, XtRBitmap, sizeof (Pixmap), Offset (scrollbar.thumb), XtRImmediate, (XtPointer) XtUnspecifiedPixmap}, {XtNforeground, XtCForeground, XtRPixel, sizeof (Pixel), Offset (scrollbar.foreground), XtRString, XtDefaultForeground}, {XtNshown, XtCShown, XtRFloat, sizeof (float), Offset (scrollbar.shown), XtRFloat, (XtPointer) &floatZero}, {XtNtopOfThumb, XtCTopOfThumb, XtRFloat, sizeof (float), Offset (scrollbar.top), XtRFloat, (XtPointer) &floatZero}, {XtNmaxOfThumb, XtCMaxOfThumb, XtRFloat, sizeof (float), Offset (scrollbar.max), XtRFloat, (XtPointer) &floatZero}, {XtNminimumThumb, XtCMinimumThumb, XtRDimension, sizeof (Dimension), Offset (scrollbar.min_thumb), XtRImmediate, (XtPointer) 7}, {XtNshadowWidth, XtCShadowWidth, XtRDimension, sizeof (Dimension), Offset (scrollbar.shadow_width), XtRImmediate, (XtPointer) 1}, {XtNtopShadowPixel, XtCTopShadowPixel, XtRPixel, sizeof (Pixel), Offset (scrollbar.top_shadow_pixel), XtRString, XtDefaultBackground}, {XtNbottomShadowPixel, XtCBottomShadowPixel, XtRPixel, sizeof (Pixel), Offset (scrollbar.bot_shadow_pixel), XtRString, XtDefaultForeground}, {XtNlimitThumb, XtCLimitThumb, XtRBool, sizeof (Bool), Offset (scrollbar.limit_thumb), XtRImmediate, (XtPointer) 0}};
XtActionsRec pullAction [2] = {{"menu-delayedpopup", (XtActionProc) gui_athena_delayed_arm_action}, {"menu-popdownsubmenus", (XtActionProc) gui_athena_popdown_submenus_action}};
char *sha_self_test_vector [] = {"ba7816bf8f01cfea414140de5dae2223" "b00361a396177a9cb410ff61f20015ad", "248d6a61d20638b8e5c026930c3e6039" "a33ce45964ff2167f6ecedd419db06c1", "cdc76e5c9914fb9281a1c7e284d73e67" "f1809a48a497200e046d39ccc7112cd0"};
char crypt_magic_head [] = "VimCrypt~";
int showcmd_visual = FALSE;
int showcmd_is_clear = TRUE;
struct nv_cmd nv_cmds [] = {{NUL, nv_error, 0, 0}, {Ctrl_A, nv_addsub, 0, 0}, {Ctrl_B, nv_page, NV_STS, BACKWARD}, {Ctrl_C, nv_esc, 0, TRUE}, {Ctrl_D, nv_halfpage, 0, 0}, {Ctrl_E, nv_scroll_line, 0, TRUE}, {Ctrl_F, nv_page, NV_STS, FORWARD}, {Ctrl_G, nv_ctrlg, 0, 0}, {Ctrl_H, nv_ctrlh, 0, 0}, {Ctrl_I, nv_pcmark, 0, 0}, {NL, nv_down, 0, FALSE}, {Ctrl_K, nv_error, 0, 0}, {Ctrl_L, nv_clear, 0, 0}, {Ctrl_M, nv_down, 0, TRUE}, {Ctrl_N, nv_down, NV_STS, FALSE}, {Ctrl_O, nv_ctrlo, 0, 0}, {Ctrl_P, nv_up, NV_STS, FALSE}, {Ctrl_Q, nv_visual, 0, FALSE}, {Ctrl_R, nv_redo, 0, 0}, {Ctrl_S, nv_ignore, 0, 0}, {Ctrl_T, nv_tagpop, NV_NCW, 0}, {Ctrl_U, nv_halfpage, 0, 0}, {Ctrl_V, nv_visual, 0, FALSE}, {'V', nv_visual, 0, FALSE}, {'v', nv_visual, 0, FALSE}, {Ctrl_W, nv_window, 0, 0}, {Ctrl_X, nv_addsub, 0, 0}, {Ctrl_Y, nv_scroll_line, 0, FALSE}, {Ctrl_Z, nv_suspend, 0, 0}, {ESC, nv_esc, 0, FALSE}, {Ctrl_BSL, nv_normal, NV_NCH_ALW, 0}, {Ctrl_RSB, nv_ident, NV_NCW, 0}, {Ctrl_HAT, nv_hat, NV_NCW, 0}, {Ctrl__, nv_error, 0, 0}, {' ', nv_right, 0, 0}, {'!', nv_operator, 0, 0}, {'"', nv_regname, NV_NCH_NOP | NV_KEEPREG, 0}, {'#', nv_ident, 0, 0}, {'$', nv_dollar, 0, 0}, {'%', nv_percent, 0, 0}, {'&', nv_optrans, 0, 0}, {'\'', nv_gomark, NV_NCH_ALW, TRUE}, {'(', nv_brace, 0, BACKWARD}, {')', nv_brace, 0, FORWARD}, {'*', nv_ident, 0, 0}, {'+', nv_down, 0, TRUE}, {',', nv_csearch, 0, TRUE}, {'-', nv_up, 0, TRUE}, {'.', nv_dot, NV_KEEPREG, 0}, {'/', nv_search, 0, FALSE}, {'0', nv_beginline, 0, 0}, {'1', nv_ignore, 0, 0}, {'2', nv_ignore, 0, 0}, {'3', nv_ignore, 0, 0}, {'4', nv_ignore, 0, 0}, {'5', nv_ignore, 0, 0}, {'6', nv_ignore, 0, 0}, {'7', nv_ignore, 0, 0}, {'8', nv_ignore, 0, 0}, {'9', nv_ignore, 0, 0}, {':', nv_colon, 0, 0}, {';', nv_csearch, 0, FALSE}, {'<', nv_operator, NV_RL, 0}, {'=', nv_operator, 0, 0}, {'>', nv_operator, NV_RL, 0}, {'?', nv_search, 0, FALSE}, {'@', nv_at, NV_NCH_NOP, FALSE}, {'A', nv_edit, 0, 0}, {'B', nv_bck_word, 0, 1}, {'C', nv_abbrev, NV_KEEPREG, 0}, {'D', nv_abbrev, NV_KEEPREG, 0}, {'E', nv_wordcmd, 0, TRUE}, {'F', nv_csearch, NV_NCH_ALW | NV_LANG, BACKWARD}, {'G', nv_goto, 0, TRUE}, {'H', nv_scroll, 0, 0}, {'I', nv_edit, 0, 0}, {'J', nv_join, 0, 0}, {'K', nv_ident, 0, 0}, {'L', nv_scroll, 0, 0}, {'M', nv_scroll, 0, 0}, {'N', nv_next, 0, SEARCH_REV}, {'O', nv_open, 0, 0}, {'P', nv_put, 0, 0}, {'Q', nv_exmode, NV_NCW, 0}, {'R', nv_Replace, 0, FALSE}, {'S', nv_subst, NV_KEEPREG, 0}, {'T', nv_csearch, NV_NCH_ALW | NV_LANG, BACKWARD}, {'U', nv_Undo, 0, 0}, {'W', nv_wordcmd, 0, TRUE}, {'X', nv_abbrev, NV_KEEPREG, 0}, {'Y', nv_abbrev, NV_KEEPREG, 0}, {'Z', nv_Zet, NV_NCH_NOP | NV_NCW, 0}, {'[', nv_brackets, NV_NCH_ALW, BACKWARD}, {'\\', nv_error, 0, 0}, {']', nv_brackets, NV_NCH_ALW, FORWARD}, {'^', nv_beginline, 0, BL_WHITE | BL_FIX}, {'_', nv_lineop, 0, 0}, {'`', nv_gomark, NV_NCH_ALW, FALSE}, {'a', nv_edit, NV_NCH, 0}, {'b', nv_bck_word, 0, 0}, {'c', nv_operator, 0, 0}, {'d', nv_operator, 0, 0}, {'e', nv_wordcmd, 0, FALSE}, {'f', nv_csearch, NV_NCH_ALW | NV_LANG, FORWARD}, {'g', nv_g_cmd, NV_NCH_ALW, FALSE}, {'h', nv_left, NV_RL, 0}, {'i', nv_edit, NV_NCH, 0}, {'j', nv_down, 0, FALSE}, {'k', nv_up, 0, FALSE}, {'l', nv_right, NV_RL, 0}, {'m', nv_mark, NV_NCH_NOP, 0}, {'n', nv_next, 0, 0}, {'o', nv_open, 0, 0}, {'p', nv_put, 0, 0}, {'q', nv_record, NV_NCH, 0}, {'r', nv_replace, NV_NCH_NOP | NV_LANG, 0}, {'s', nv_subst, NV_KEEPREG, 0}, {'t', nv_csearch, NV_NCH_ALW | NV_LANG, FORWARD}, {'u', nv_undo, 0, 0}, {'w', nv_wordcmd, 0, FALSE}, {'x', nv_abbrev, NV_KEEPREG, 0}, {'y', nv_operator, 0, 0}, {'z', nv_zet, NV_NCH_ALW, 0}, {'{', nv_findpar, 0, BACKWARD}, {'|', nv_pipe, 0, 0}, {'}', nv_findpar, 0, FORWARD}, {'~', nv_tilde, 0, 0}, {POUND, nv_ident, 0, 0}, {K_MOUSEUP, nv_mousescroll, 0, MSCR_UP}, {K_MOUSEDOWN, nv_mousescroll, 0, MSCR_DOWN}, {K_MOUSELEFT, nv_mousescroll, 0, MSCR_LEFT}, {K_MOUSERIGHT, nv_mousescroll, 0, MSCR_RIGHT}, {K_LEFTMOUSE, nv_mouse, 0, 0}, {K_LEFTMOUSE_NM, nv_mouse, 0, 0}, {K_LEFTDRAG, nv_mouse, 0, 0}, {K_LEFTRELEASE, nv_mouse, 0, 0}, {K_LEFTRELEASE_NM, nv_mouse, 0, 0}, {K_MOUSEMOVE, nv_mouse, 0, 0}, {
  K_MIDDLEMOUSE, nv_mouse, 0, 0}, {K_MIDDLEDRAG, nv_mouse, 0, 0}, {K_MIDDLERELEASE, nv_mouse, 0, 0}, {K_RIGHTMOUSE, nv_mouse, 0, 0}, {K_RIGHTDRAG, nv_mouse, 0, 0}, {K_RIGHTRELEASE, nv_mouse, 0, 0}, {K_X1MOUSE, nv_mouse, 0, 0}, {K_X1DRAG, nv_mouse, 0, 0}, {K_X1RELEASE, nv_mouse, 0, 0}, {K_X2MOUSE, nv_mouse, 0, 0}, {K_X2DRAG, nv_mouse, 0, 0}, {K_X2RELEASE, nv_mouse, 0, 0}, {K_IGNORE, nv_ignore, NV_KEEPREG, 0}, {K_NOP, nv_nop, 0, 0}, {K_INS, nv_edit, 0, 0}, {K_KINS, nv_edit, 0, 0}, {K_BS, nv_ctrlh, 0, 0}, {K_UP, nv_up, NV_SSS | NV_STS, FALSE}, {K_S_UP, nv_page, NV_SS, BACKWARD}, {K_DOWN, nv_down, NV_SSS | NV_STS, FALSE}, {K_S_DOWN, nv_page, NV_SS, FORWARD}, {K_LEFT, nv_left, NV_SSS | NV_STS | NV_RL, 0}, {K_S_LEFT, nv_bck_word, NV_SS | NV_RL, 0}, {K_C_LEFT, nv_bck_word, NV_SSS | NV_RL | NV_STS, 1}, {K_RIGHT, nv_right, NV_SSS | NV_STS | NV_RL, 0}, {K_S_RIGHT, nv_wordcmd, NV_SS | NV_RL, FALSE}, {K_C_RIGHT, nv_wordcmd, NV_SSS | NV_RL | NV_STS, TRUE}, {K_PAGEUP, nv_page, NV_SSS | NV_STS, BACKWARD}, {K_KPAGEUP, nv_page, NV_SSS | NV_STS, BACKWARD}, {K_PAGEDOWN, nv_page, NV_SSS | NV_STS, FORWARD}, {K_KPAGEDOWN, nv_page, NV_SSS | NV_STS, FORWARD}, {K_END, nv_end, NV_SSS | NV_STS, FALSE}, {K_KEND, nv_end, NV_SSS | NV_STS, FALSE}, {K_S_END, nv_end, NV_SS, FALSE}, {K_C_END, nv_end, NV_SSS | NV_STS, TRUE}, {K_HOME, nv_home, NV_SSS | NV_STS, 0}, {K_KHOME, nv_home, NV_SSS | NV_STS, 0}, {K_S_HOME, nv_home, NV_SS, 0}, {K_C_HOME, nv_goto, NV_SSS | NV_STS, FALSE}, {K_DEL, nv_abbrev, 0, 0}, {K_KDEL, nv_abbrev, 0, 0}, {K_UNDO, nv_kundo, 0, 0}, {K_HELP, nv_help, NV_NCW, 0}, {K_F1, nv_help, NV_NCW, 0}, {K_XF1, nv_help, NV_NCW, 0}, {K_SELECT, nv_select, 0, 0}, {K_VER_SCROLLBAR, nv_ver_scrollbar, 0, 0}, {K_HOR_SCROLLBAR, nv_hor_scrollbar, 0, 0}, {K_F8, farsi_f8, 0, 0}, {K_F9, farsi_f9, 0, 0}, {K_F21, nv_nbcmd, NV_NCH_ALW, 0}, {K_CURSORHOLD, nv_cursorhold, NV_KEEPREG, 0}, {K_PS, nv_edit, 0, 0},};
int *nfa_timed_out;
char_u e_ill_char_class [] = N_ ("E877: (NFA regexp) Invalid character class: %ld");
char_u e_misplaced [] = N_ ("E866: (NFA regexp) Misplaced %c");
char *msg_loclist = N_ ("[Location List]");
char opchars [] [3] = {{NUL, NUL, FALSE}, {'d', NUL, FALSE}, {'y', NUL, FALSE}, {'c', NUL, FALSE}, {'<', NUL, TRUE}, {'>', NUL, TRUE}, {'!', NUL, TRUE}, {'g', '~', FALSE}, {'=', NUL, TRUE}, {'g', 'q', TRUE}, {':', NUL, TRUE}, {'g', 'U', FALSE}, {'g', 'u', FALSE}, {'J', NUL, TRUE}, {'g', 'J', TRUE}, {'g', '?', FALSE}, {'r', NUL, FALSE}, {'I', NUL, FALSE}, {'A', NUL, FALSE}, {'z', 'f', TRUE}, {'z', 'o', TRUE}, {'z', 'O', TRUE}, {'z', 'c', TRUE}, {'z', 'C', TRUE}, {'z', 'd', TRUE}, {'z', 'D', TRUE}, {'g', 'w', TRUE}, {'g', '@', FALSE}, {Ctrl_A, NUL, FALSE}, {Ctrl_X, NUL, FALSE},};
int inputsecret_flag = 0;
struct fst functions [] = {{"abs", 1, 1, f_abs}, {"acos", 1, 1, f_acos}, {"add", 2, 2, f_add}, {"and", 2, 2, f_and}, {"append", 2, 2, f_append}, {"argc", 0, 0, f_argc}, {"argidx", 0, 0, f_argidx}, {"arglistid", 0, 2, f_arglistid}, {"argv", 0, 1, f_argv}, {"asin", 1, 1, f_asin}, {"assert_beeps", 1, 2, f_assert_beeps}, {"assert_equal", 2, 3, f_assert_equal}, {"assert_exception", 1, 2, f_assert_exception}, {"assert_fails", 1, 2, f_assert_fails}, {"assert_false", 1, 2, f_assert_false}, {"assert_inrange", 3, 4, f_assert_inrange}, {"assert_match", 2, 3, f_assert_match}, {"assert_notequal", 2, 3, f_assert_notequal}, {"assert_notmatch", 2, 3, f_assert_notmatch}, {"assert_report", 1, 1, f_assert_report}, {"assert_true", 1, 2, f_assert_true}, {"atan", 1, 1, f_atan}, {"atan2", 2, 2, f_atan2}, {"balloon_show", 1, 1, f_balloon_show}, {"balloon_split", 1, 1, f_balloon_split}, {"browse", 4, 4, f_browse}, {"browsedir", 2, 2, f_browsedir}, {"bufexists", 1, 1, f_bufexists}, {"buffer_exists", 1, 1, f_bufexists}, {"buffer_name", 1, 1, f_bufname}, {"buffer_number", 1, 1, f_bufnr}, {"buflisted", 1, 1, f_buflisted}, {"bufloaded", 1, 1, f_bufloaded}, {"bufname", 1, 1, f_bufname}, {"bufnr", 1, 2, f_bufnr}, {"bufwinid", 1, 1, f_bufwinid}, {"bufwinnr", 1, 1, f_bufwinnr}, {"byte2line", 1, 1, f_byte2line}, {"byteidx", 2, 2, f_byteidx}, {"byteidxcomp", 2, 2, f_byteidxcomp}, {"call", 2, 3, f_call}, {"ceil", 1, 1, f_ceil}, {"ch_canread", 1, 1, f_ch_canread}, {"ch_close", 1, 1, f_ch_close}, {"ch_close_in", 1, 1, f_ch_close_in}, {"ch_evalexpr", 2, 3, f_ch_evalexpr}, {"ch_evalraw", 2, 3, f_ch_evalraw}, {"ch_getbufnr", 2, 2, f_ch_getbufnr}, {"ch_getjob", 1, 1, f_ch_getjob}, {"ch_info", 1, 1, f_ch_info}, {"ch_log", 1, 2, f_ch_log}, {"ch_logfile", 1, 2, f_ch_logfile}, {"ch_open", 1, 2, f_ch_open}, {"ch_read", 1, 2, f_ch_read}, {"ch_readraw", 1, 2, f_ch_readraw}, {"ch_sendexpr", 2, 3, f_ch_sendexpr}, {"ch_sendraw", 2, 3, f_ch_sendraw}, {"ch_setoptions", 2, 2, f_ch_setoptions}, {"ch_status", 1, 2, f_ch_status}, {"changenr", 0, 0, f_changenr}, {"char2nr", 1, 2, f_char2nr}, {"cindent", 1, 1, f_cindent}, {"clearmatches", 0, 0, f_clearmatches}, {"col", 1, 1, f_col}, {"complete", 2, 2, f_complete}, {"complete_add", 1, 1, f_complete_add}, {"complete_check", 0, 0, f_complete_check}, {"confirm", 1, 4, f_confirm}, {"copy", 1, 1, f_copy}, {"cos", 1, 1, f_cos}, {"cosh", 1, 1, f_cosh}, {"count", 2, 4, f_count}, {"cscope_connection", 0, 3, f_cscope_connection}, {"cursor", 1, 3, f_cursor}, {"deepcopy", 1, 2, f_deepcopy}, {"delete", 1, 2, f_delete}, {"did_filetype", 0, 0, f_did_filetype}, {"diff_filler", 1, 1, f_diff_filler}, {"diff_hlID", 2, 2, f_diff_hlID}, {"empty", 1, 1, f_empty}, {"escape", 2, 2, f_escape}, {"eval", 1, 1, f_eval}, {"eventhandler", 0, 0, f_eventhandler}, {"executable", 1, 1, f_executable}, {"execute", 1, 2, f_execute}, {"exepath", 1, 1, f_exepath}, {"exists", 1, 1, f_exists}, {"exp", 1, 1, f_exp}, {"expand", 1, 3, f_expand}, {"extend", 2, 3, f_extend}, {"feedkeys", 1, 2, f_feedkeys}, {"file_readable", 1, 1, f_filereadable}, {"filereadable", 1, 1, f_filereadable}, {"filewritable", 1, 1, f_filewritable}, {"filter", 2, 2, f_filter}, {"finddir", 1, 3, f_finddir}, {"findfile", 1, 3, f_findfile}, {"float2nr", 1, 1, f_float2nr}, {"floor", 1, 1, f_floor}, {"fmod", 2, 2, f_fmod}, {"fnameescape", 1, 1, f_fnameescape}, {"fnamemodify", 2, 2, f_fnamemodify}, {"foldclosed", 1, 1, f_foldclosed}, {"foldclosedend", 1, 1, f_foldclosedend}, {"foldlevel", 1, 1, f_foldlevel}, {"foldtext", 0, 0, f_foldtext}, {"foldtextresult", 1, 1, f_foldtextresult}, {"foreground", 0, 0, f_foreground}, {"funcref", 1, 3, f_funcref}, {"function", 1, 3, f_function}, {"garbagecollect", 0, 1, f_garbagecollect}, {"get", 2, 3, f_get}, {"getbufinfo", 0, 1, f_getbufinfo}, {"getbufline", 2, 3, f_getbufline}, {"getbufvar", 2, 3, f_getbufvar}, {"getchangelist", 1, 1, f_getchangelist}, {"getchar", 0, 1, f_getchar}, {"getcharmod", 0, 0, f_getcharmod}, {"getcharsearch", 0, 0, f_getcharsearch}, {"getcmdline", 0, 0, f_getcmdline}, {"getcmdpos", 0, 0, f_getcmdpos}, {"getcmdtype", 0, 0, f_getcmdtype}, {
  "getcmdwintype", 0, 0, f_getcmdwintype}, {"getcompletion", 2, 3, f_getcompletion}, {"getcurpos", 0, 0, f_getcurpos}, {"getcwd", 0, 2, f_getcwd}, {"getfontname", 0, 1, f_getfontname}, {"getfperm", 1, 1, f_getfperm}, {"getfsize", 1, 1, f_getfsize}, {"getftime", 1, 1, f_getftime}, {"getftype", 1, 1, f_getftype}, {"getjumplist", 0, 2, f_getjumplist}, {"getline", 1, 2, f_getline}, {"getloclist", 1, 2, f_getloclist}, {"getmatches", 0, 0, f_getmatches}, {"getpid", 0, 0, f_getpid}, {"getpos", 1, 1, f_getpos}, {"getqflist", 0, 1, f_getqflist}, {"getreg", 0, 3, f_getreg}, {"getregtype", 0, 1, f_getregtype}, {"gettabinfo", 0, 1, f_gettabinfo}, {"gettabvar", 2, 3, f_gettabvar}, {"gettabwinvar", 3, 4, f_gettabwinvar}, {"getwininfo", 0, 1, f_getwininfo}, {"getwinposx", 0, 0, f_getwinposx}, {"getwinposy", 0, 0, f_getwinposy}, {"getwinvar", 2, 3, f_getwinvar}, {"glob", 1, 4, f_glob}, {"glob2regpat", 1, 1, f_glob2regpat}, {"globpath", 2, 5, f_globpath}, {"has", 1, 1, f_has}, {"has_key", 2, 2, f_has_key}, {"haslocaldir", 0, 2, f_haslocaldir}, {"hasmapto", 1, 3, f_hasmapto}, {"highlightID", 1, 1, f_hlID}, {"highlight_exists", 1, 1, f_hlexists}, {"histadd", 2, 2, f_histadd}, {"histdel", 1, 2, f_histdel}, {"histget", 1, 2, f_histget}, {"histnr", 1, 1, f_histnr}, {"hlID", 1, 1, f_hlID}, {"hlexists", 1, 1, f_hlexists}, {"hostname", 0, 0, f_hostname}, {"iconv", 3, 3, f_iconv}, {"indent", 1, 1, f_indent}, {"index", 2, 4, f_index}, {"input", 1, 3, f_input}, {"inputdialog", 1, 3, f_inputdialog}, {"inputlist", 1, 1, f_inputlist}, {"inputrestore", 0, 0, f_inputrestore}, {"inputsave", 0, 0, f_inputsave}, {"inputsecret", 1, 2, f_inputsecret}, {"insert", 2, 3, f_insert}, {"invert", 1, 1, f_invert}, {"isdirectory", 1, 1, f_isdirectory}, {"islocked", 1, 1, f_islocked}, {"items", 1, 1, f_items}, {"job_getchannel", 1, 1, f_job_getchannel}, {"job_info", 1, 1, f_job_info}, {"job_setoptions", 2, 2, f_job_setoptions}, {"job_start", 1, 2, f_job_start}, {"job_status", 1, 1, f_job_status}, {"job_stop", 1, 2, f_job_stop}, {"join", 1, 2, f_join}, {"js_decode", 1, 1, f_js_decode}, {"js_encode", 1, 1, f_js_encode}, {"json_decode", 1, 1, f_json_decode}, {"json_encode", 1, 1, f_json_encode}, {"keys", 1, 1, f_keys}, {"last_buffer_nr", 0, 0, f_last_buffer_nr}, {"len", 1, 1, f_len}, {"libcall", 3, 3, f_libcall}, {"libcallnr", 3, 3, f_libcallnr}, {"line", 1, 1, f_line}, {"line2byte", 1, 1, f_line2byte}, {"lispindent", 1, 1, f_lispindent}, {"localtime", 0, 0, f_localtime}, {"log", 1, 1, f_log}, {"log10", 1, 1, f_log10}, {"map", 2, 2, f_map}, {"maparg", 1, 4, f_maparg}, {"mapcheck", 1, 3, f_mapcheck}, {"match", 2, 4, f_match}, {"matchadd", 2, 5, f_matchadd}, {"matchaddpos", 2, 5, f_matchaddpos}, {"matcharg", 1, 1, f_matcharg}, {"matchdelete", 1, 1, f_matchdelete}, {"matchend", 2, 4, f_matchend}, {"matchlist", 2, 4, f_matchlist}, {"matchstr", 2, 4, f_matchstr}, {"matchstrpos", 2, 4, f_matchstrpos}, {"max", 1, 1, f_max}, {"min", 1, 1, f_min}, {"mode", 0, 1, f_mode}, {"nextnonblank", 1, 1, f_nextnonblank}, {"nr2char", 1, 2, f_nr2char}, {"or", 2, 2, f_or}, {"pathshorten", 1, 1, f_pathshorten}, {"pow", 2, 2, f_pow}, {"prevnonblank", 1, 1, f_prevnonblank}, {"printf", 2, 19, f_printf}, {"pumvisible", 0, 0, f_pumvisible}, {"range", 1, 3, f_range}, {"readfile", 1, 3, f_readfile}, {"reltime", 0, 2, f_reltime}, {"reltimefloat", 1, 1, f_reltimefloat}, {"reltimestr", 1, 1, f_reltimestr}, {"remote_expr", 2, 4, f_remote_expr}, {"remote_foreground", 1, 1, f_remote_foreground}, {"remote_peek", 1, 2, f_remote_peek}, {"remote_read", 1, 2, f_remote_read}, {"remote_send", 2, 3, f_remote_send}, {"remote_startserver", 1, 1, f_remote_startserver}, {"remove", 2, 3, f_remove}, {"rename", 2, 2, f_rename}, {"repeat", 2, 2, f_repeat}, {"resolve", 1, 1, f_resolve}, {"reverse", 1, 1, f_reverse}, {"round", 1, 1, f_round}, {"screenattr", 2, 2, f_screenattr}, {"screenchar", 2, 2, f_screenchar}, {"screencol", 0, 0, f_screencol}, {"screenrow", 0, 0, f_screenrow}, {"search", 1, 4, f_search}, {"searchdecl", 1, 3, f_searchdecl}, {"searchpair", 3, 7, f_searchpair}, {"searchpairpos", 3, 7, f_searchpairpos}, {
  "searchpos", 1, 4, f_searchpos}, {"server2client", 2, 2, f_server2client}, {"serverlist", 0, 0, f_serverlist}, {"setbufline", 3, 3, f_setbufline}, {"setbufvar", 3, 3, f_setbufvar}, {"setcharsearch", 1, 1, f_setcharsearch}, {"setcmdpos", 1, 1, f_setcmdpos}, {"setfperm", 2, 2, f_setfperm}, {"setline", 2, 2, f_setline}, {"setloclist", 2, 4, f_setloclist}, {"setmatches", 1, 1, f_setmatches}, {"setpos", 2, 2, f_setpos}, {"setqflist", 1, 3, f_setqflist}, {"setreg", 2, 3, f_setreg}, {"settabvar", 3, 3, f_settabvar}, {"settabwinvar", 4, 4, f_settabwinvar}, {"setwinvar", 3, 3, f_setwinvar}, {"sha256", 1, 1, f_sha256}, {"shellescape", 1, 2, f_shellescape}, {"shiftwidth", 0, 0, f_shiftwidth}, {"simplify", 1, 1, f_simplify}, {"sin", 1, 1, f_sin}, {"sinh", 1, 1, f_sinh}, {"sort", 1, 3, f_sort}, {"soundfold", 1, 1, f_soundfold}, {"spellbadword", 0, 1, f_spellbadword}, {"spellsuggest", 1, 3, f_spellsuggest}, {"split", 1, 3, f_split}, {"sqrt", 1, 1, f_sqrt}, {"str2float", 1, 1, f_str2float}, {"str2nr", 1, 2, f_str2nr}, {"strcharpart", 2, 3, f_strcharpart}, {"strchars", 1, 2, f_strchars}, {"strdisplaywidth", 1, 2, f_strdisplaywidth}, {"strgetchar", 2, 2, f_strgetchar}, {"stridx", 2, 3, f_stridx}, {"string", 1, 1, f_string}, {"strlen", 1, 1, f_strlen}, {"strpart", 2, 3, f_strpart}, {"strridx", 2, 3, f_strridx}, {"strtrans", 1, 1, f_strtrans}, {"strwidth", 1, 1, f_strwidth}, {"submatch", 1, 2, f_submatch}, {"substitute", 4, 4, f_substitute}, {"synID", 3, 3, f_synID}, {"synIDattr", 2, 3, f_synIDattr}, {"synIDtrans", 1, 1, f_synIDtrans}, {"synconcealed", 2, 2, f_synconcealed}, {"synstack", 2, 2, f_synstack}, {"system", 1, 2, f_system}, {"systemlist", 1, 2, f_systemlist}, {"tabpagebuflist", 0, 1, f_tabpagebuflist}, {"tabpagenr", 0, 1, f_tabpagenr}, {"tabpagewinnr", 1, 2, f_tabpagewinnr}, {"tagfiles", 0, 0, f_tagfiles}, {"taglist", 1, 2, f_taglist}, {"tan", 1, 1, f_tan}, {"tanh", 1, 1, f_tanh}, {"tempname", 0, 0, f_tempname}, {"term_getaltscreen", 1, 1, f_term_getaltscreen}, {"term_getattr", 2, 2, f_term_getattr}, {"term_getcursor", 1, 1, f_term_getcursor}, {"term_getjob", 1, 1, f_term_getjob}, {"term_getline", 2, 2, f_term_getline}, {"term_getscrolled", 1, 1, f_term_getscrolled}, {"term_getsize", 1, 1, f_term_getsize}, {"term_getstatus", 1, 1, f_term_getstatus}, {"term_gettitle", 1, 1, f_term_gettitle}, {"term_gettty", 1, 2, f_term_gettty}, {"term_list", 0, 0, f_term_list}, {"term_scrape", 2, 2, f_term_scrape}, {"term_sendkeys", 2, 2, f_term_sendkeys}, {"term_start", 1, 2, f_term_start}, {"term_wait", 1, 2, f_term_wait}, {"test_alloc_fail", 3, 3, f_test_alloc_fail}, {"test_autochdir", 0, 0, f_test_autochdir}, {"test_feedinput", 1, 1, f_test_feedinput}, {"test_garbagecollect_now", 0, 0, f_test_garbagecollect_now}, {"test_ignore_error", 1, 1, f_test_ignore_error}, {"test_null_channel", 0, 0, f_test_null_channel}, {"test_null_dict", 0, 0, f_test_null_dict}, {"test_null_job", 0, 0, f_test_null_job}, {"test_null_list", 0, 0, f_test_null_list}, {"test_null_partial", 0, 0, f_test_null_partial}, {"test_null_string", 0, 0, f_test_null_string}, {"test_override", 2, 2, f_test_override}, {"test_settime", 1, 1, f_test_settime}, {"timer_info", 0, 1, f_timer_info}, {"timer_pause", 2, 2, f_timer_pause}, {"timer_start", 2, 3, f_timer_start}, {"timer_stop", 1, 1, f_timer_stop}, {"timer_stopall", 0, 0, f_timer_stopall}, {"tolower", 1, 1, f_tolower}, {"toupper", 1, 1, f_toupper}, {"tr", 3, 3, f_tr}, {"trunc", 1, 1, f_trunc}, {"type", 1, 1, f_type}, {"undofile", 1, 1, f_undofile}, {"undotree", 0, 0, f_undotree}, {"uniq", 1, 3, f_uniq}, {"values", 1, 1, f_values}, {"virtcol", 1, 1, f_virtcol}, {"visualmode", 0, 1, f_visualmode}, {"wildmenumode", 0, 0, f_wildmenumode}, {"win_findbuf", 1, 1, f_win_findbuf}, {"win_getid", 0, 2, f_win_getid}, {"win_gotoid", 1, 1, f_win_gotoid}, {"win_id2tabwin", 1, 1, f_win_id2tabwin}, {"win_id2win", 1, 1, f_win_id2win}, {"win_screenpos", 1, 1, f_win_screenpos}, {"winbufnr", 1, 1, f_winbufnr}, {"wincol", 0, 0, f_wincol}, {"winheight", 1, 1, f_winheight}, {"winline", 0, 0, f_winline}, {"winnr", 0, 1, f_winnr}, {"winrestcmd", 0, 0,
  f_winrestcmd}, {"winrestview", 1, 1, f_winrestview}, {"winsaveview", 0, 0, f_winsaveview}, {"winwidth", 1, 1, f_winwidth}, {"wordcount", 0, 0, f_wordcount}, {"writefile", 2, 3, f_writefile}, {"xor", 2, 2, f_xor},};
int cls_bigword;
int cmd_fkmap = 0;
int cmd_hkmap = 0;
int extra_char_shift;
int extra_char = NUL;
int cmd_showtail;
VTermScreenCallbacks screen_callbacks = {handle_damage, handle_moverect, handle_movecursor, handle_settermprop, NULL, handle_resize, handle_pushline, NULL};
int inAtomic = 0;
int r_cmdno;
channel_T *nb_channel = NULL;
int old_char = -1;
int block_redo = FALSE;
char_u menu_mode_chars [] = {'n', 'v', 's', 'o', 'i', 'c', 't'};
char *cmds [] = {"define", 
    # define SIGNCMD_DEFINE	0
    "undefine", 
    # define SIGNCMD_UNDEFINE 1
    "list", 
    # define SIGNCMD_LIST	2
    "place", 
    # define SIGNCMD_PLACE	3
    "unplace", 
    # define SIGNCMD_UNPLACE 4
    "jump", 
    # define SIGNCMD_JUMP	5
    NULL 
    # define SIGNCMD_LAST	6

};
int viminfo_errcnt;
int sort_ic;
const char *dlg_icons [] = {"IDR_VIM", "IDR_VIM_ERROR", "IDR_VIM_ALERT", "IDR_VIM_INFO", "IDR_VIM_QUESTION"};
DWORD LastActivity = 0;
UINT_PTR BevalTimerId = 0;
int s_timed_out = FALSE;
int s_getting_focus = FALSE;
int s_need_activate = FALSE;
WNDPROC s_toolbar_wndproc = NULL;
HDC s_hdc = NULL;
int s_busy_processing = FALSE;
int cause_abort = FALSE;
struct cmdmod cmdmods [] = {{"aboveleft", 3, FALSE}, {"belowright", 3, FALSE}, {"botright", 2, FALSE}, {"browse", 3, FALSE}, {"confirm", 4, FALSE}, {"filter", 4, FALSE}, {"hide", 3, FALSE}, {"keepalt", 5, FALSE}, {"keepjumps", 5, FALSE}, {"keepmarks", 3, FALSE}, {"keeppatterns", 5, FALSE}, {"leftabove", 5, FALSE}, {"lockmarks", 3, FALSE}, {"noautocmd", 3, FALSE}, {"noswapfile", 3, FALSE}, {"rightbelow", 6, FALSE}, {"sandbox", 3, FALSE}, {"silent", 3, FALSE}, {"tab", 3, TRUE}, {"topleft", 2, FALSE}, {"unsilent", 3, FALSE}, {"verbose", 4, TRUE}, {"vertical", 4, FALSE},};
char_u dollar_command [2] = {'$', 0};
garray_T ucmds = {0, 0, sizeof (ucmd_T), 4, NULL};
DWORD g_cmodeout = 0;
DWORD g_cmodein = 0;
CONSOLE_CURSOR_INFO g_cci;
BOOL g_fCanChangeIcon = FALSE;
HICON g_hVimIcon = NULL;
HICON g_hOrigIcon = NULL;
HICON g_hOrigIconSmall = NULL;
int g_nMouseClick = -1;
int g_fMouseActive = FALSE;
BOOL g_fJustGotFocus = FALSE;
int g_fForceExit = FALSE;
COORD g_coord;
SMALL_RECT g_srScrollRegion;
int redrawing_for_callback = 0;
proftime_T inchar_time;
char *pexpand_cmds [] = {"start", 
    #define PROFCMD_START	0
    "pause", 
    #define PROFCMD_PAUSE	1
    "continue", 
    #define PROFCMD_CONTINUE 2
    "func", 
    #define PROFCMD_FUNC	3
    "file", 
    #define PROFCMD_FILE	4
    NULL 
    #define PROFCMD_LAST	5

};
char_u *debug_newval = NULL;
char_u *debug_oldval = NULL;
garray_T script_items = {0, 0, sizeof (scriptitem_T), 4, NULL};
char *e_cannot_connect = N_ ("E902: Cannot connect to port");
channel_T *first_channel = NULL;
int safe_to_invoke_callback = 0;
int channel_need_redraw = FALSE;
dict_T *first_dict = NULL;
char *e_nofunc = N_ ("E130: Unknown function: %s");
char *e_funcref = N_ ("E718: Funcref required");
char *e_funcdict = N_ ("E717: Dictionary entry already exists");
char *e_funcexts = N_ ("E122: Function %s already exists, add ! to replace it");
garray_T funcargs = GA_EMPTY;
hashtab_T func_hashtab;
long  replace_stack_nr = 0;
char_u *replace_stack = NULL;
char_u pc_bytes [MB_MAXBYTES + 1];
int pc_status;
int dont_sync_undo = FALSE;
int revins_chars;
int can_cindent;
int compl_opt_refresh_always = FALSE;
expand_T compl_xp;
int compl_cont_mode = 0;
char_u *compl_orig_text = NULL;
int compl_busy = FALSE;
int ctrl_x_mode = CTRL_X_NORMAL;
int compl_was_interrupted = FALSE;
int compl_no_select = FALSE;
int compl_no_insert = FALSE;
int compl_get_longest = FALSE;
char_u *compl_leader = NULL;
int compl_enter_selects = FALSE;
char *ctrl_x_msgs [] = {N_ (" Keyword completion (^N^P)"), N_ (" ^X mode (^]^D^E^F^I^K^L^N^O^Ps^U^V^Y)"), NULL, N_ (" Whole line completion (^L^N^P)"), N_ (" File name completion (^F^N^P)"), N_ (" Tag completion (^]^N^P)"), N_ (" Path pattern completion (^N^P)"), N_ (" Definition completion (^D^N^P)"), NULL, N_ (" Dictionary completion (^K^N^P)"), N_ (" Thesaurus completion (^T^N^P)"), N_ (" Command-line completion (^V^N^P)"), N_ (" User defined completion (^U^N^P)"), N_ (" Omni completion (^O^N^P)"), N_ (" Spelling suggestion (s^N^P)"), N_ (" Keyword Local completion (^N^P)"), NULL,};
volatile int in_mch_delay = FALSE;
char_u *oldicon = NULL;
garray_T ga_scripts = {0, 0, sizeof (scriptvar_T *), 4, NULL};
char *e_dictrange = N_ ("E719: Cannot use [:] with a Dictionary");
char *e_missbrac = N_ ("E111: Missing ']'");
int autocmd_nested = FALSE;
int autocmd_blocked = 0;
int au_need_clean = FALSE;
AutoPatCmd *active_apc_list = NULL;
int default_reload_choice = 0;
sb_clear_T do_clear_sb_text = SB_CLEAR_NONE;
int emsg_to_channel_log = FALSE;
int close_win = FALSE;
BPTR raw_out = (BPTR) NULL;
int process_still_running;
int fold_changed;
int pum_scrollbar;
int pum_selected;
int xt_index_out = 0;
RGBColor specialColor;
UInt32 useAntialias_cached = 0x0;
Boolean gIsFontFallbackSet;
ControlActionUPP gScrollDrag;
ControlActionUPP gScrollAction;
short  clickIsPopup;
short  dragRectControl;
short  dragRectEnbl;
Rect dragRect;
TSMDocumentID gTSMDocument;
int im_is_active = FALSE;
long  bl_minval;
garray_T regstack = {0, 0, 0, 0, NULL};
char_u *classchars = (char_u *) ".iIkKfFpPsSdDxXoOwWhHaAlLuU";
int reg_cpo_bsl;
int reg_cpo_lit;
int reg_strict;
int reg_magic;
int one_exactly = FALSE;
long  brace_min [10];
int num_complex_braces;
short  class_tab [256];
char_u e_missingbracket [] = N_ ("E769: Missing ] after %s[");
int im_was_set_active = FALSE;
char_u g_chartab [256];
int chartab_initialized = FALSE;
void *fdip_search_ctx = NULL;
int spell_expand_need_cap;
EXTERN char_u *p_lispwords;
EXTERN char_u e_invcmd [] INIT (= N_ ("E476: Invalid command"));
int dosetvisible = FALSE;
int regnpar;
char_u *regparse;
EXTERN char_u *p_pexpr;
EXTERN char_u *p_bexpr;
EXTERN proftime_T bevalexpr_due;
EXTERN char_u e_invexpr2 [] INIT (= N_ ("E15: Invalid expression: %s"));
int nfa_has_zsubexpr;
int debug_expr = 0;
int need_clear_zsubexpr = FALSE;
int need_clear_subexpr;
EXTERN char_u e_au_recursive [] INIT (= N_ ("E952: Autocommand caused recursive behavior"));
EXTERN char_u e_secure [] INIT (= N_ ("E523: Not allowed here"));
EXTERN pos_T saved_cursor;
EXTERN tabpage_T *curtab;
EXTERN win_T *curwin;
EXTERN int current_scrollbar;
EXTERN vimmenu_T *current_menu;
int want_movecursor = 0;
long_u curr_fg;
long_u curr_bg;
int curr_bold;
int curr_italic;
int A_is_f (int cur_c);
int A_is_s (int cur_c);
int A_is_a (int cur_c);
PtCallbackF_t gui_ph_handle_timer_cursor;
PtWidget_t *gui_ph_timer_cursor;
vimmenu_T *a_cur_menu = NULL;
yankreg_T *y_current;
int desired_cursor_blink = -1;
int desired_cursor_shape = -1;
BalloonEval *cur_beval = NULL;
int s_cursor_visible = TRUE;
schar_T *current_ScreenLine;
funccall_T *current_funccal = NULL;
int tv_equal_recurse_limit;
int current_copyID = 0;
int initial_cursor_blink = FALSE;
int initial_cursor_shape_blink = FALSE;
int initial_cursor_shape = 0;
int can_update_cursor = TRUE;
RgnHandle cursorRgn;
int curchr;
EXTERN long  p_ttm;
EXTERN long  p_tm;
EXTERN int p_stmp;
EXTERN int p_lrm;
EXTERN int p_confirm;
EXTERN char_u e_invexprmsg [] INIT (= N_ ("E449: Invalid expression received"));
EXTERN char_u e_notmp [] INIT (= N_ ("E483: Can't get temp file name"));
SPELL_EXTERN char e_format [] SPELL_INIT (= N_ ("E759: Format error in spell file"));
int prt_attribute_change;
Widget textAreaForm;
Widget vimForm;
Pixmap pullerBitmap = None;
XtTranslations supermenuTrans;
Widget vimForm = (Widget) 0;
cryptmethod_T cryptmethods [CRYPT_M_COUNT] = {{"zip", "VimCrypt~01!", 0, 0, TRUE, FALSE, NULL, crypt_zip_init, crypt_zip_encode, crypt_zip_decode, NULL, NULL, crypt_zip_encode, crypt_zip_decode,}, {"blowfish", "VimCrypt~02!", 8, 8, TRUE, FALSE, blowfish_self_test, crypt_blowfish_init, crypt_blowfish_encode, crypt_blowfish_decode, NULL, NULL, crypt_blowfish_encode, crypt_blowfish_decode,}, {"blowfish2", "VimCrypt~03!", 8, 8, TRUE, TRUE, blowfish_self_test, crypt_blowfish_init, crypt_blowfish_encode, crypt_blowfish_decode, NULL, NULL, crypt_blowfish_encode, crypt_blowfish_decode,},};
struct initmap initmappings [] = {{(char_u *) "<Backspace> \"-d", VIS_SEL},};
char_u e_othermode [] = N_ ("E328: Menu only exists in another mode");
LOGFONT norm_logfont;
int quitmore = 0;
WORD g_attrPreStandout = 0;
int g_fTermcapMode = FALSE;
ConsoleBuffer g_cbTermcap = {0};
ConsoleBuffer g_cbNonTermcap = {0};
DWORD g_PlatformId;
WORD g_attrCurrent;
WORD g_attrDefault = 7;
int screen_char_attr = 0;
int screen_attr = 0;
int pc_attr;
int curr_tmode = TMODE_COOK;
int echo_attr = 0;
char_u *confirm_msg_tail;
char_u *confirm_msg = NULL;
int confirm_msg_used = FALSE;
EXTERN char_u *p_titlestring;
EXTERN char_u *p_iconstring;
char *e_stringreq = N_ ("E928: String required");
char *e_float_as_string = N_ ("E806: using Float as a String");
int reg_string;
pylinkedlist_T *lastfunc = NULL;
pylinkedlist_T *lastlist = NULL;
pylinkedlist_T *lastdict = NULL;
PyObject *vim_special_path_object;
const char *vim_special_path = "_vim_path_";
EXTERN char_u *p_cdpath;
EXTERN char_u *p_path;
EXTERN char_u e_invalpat [] INIT (= N_ ("E682: Invalid search pattern or delimiter"));
EXTERN char_u e_patnotf2 [] INIT (= N_ ("E486: Pattern not found: %s"));
EXTERN char_u e_patnotf [] INIT (= N_ ("Pattern not found"));
EXTERN char_u e_nolastcmd [] INIT (= N_ ("E30: No previous command line"));
EXTERN char_u e_nogroup [] INIT (= N_ ("E28: No such highlight group name: %s"));
EXTERN pos_T last_cursormoved;
EXTERN win_T *lastwin;
int last_shape = 0;
int lastmark = 0;
struct fmtpattern fmt_pat [FMT_PATTERNS] = {{'f', ".\\+"}, {'n', "\\d\\+"}, {'l', "\\d\\+"}, {'c', "\\d\\+"}, {'t', "."}, {'m', ".\\+"}, {'r', ".*"}, {'p', "[- 	.]*"}, {'v', "\\d\\+"}, {'s', ".\\+"}};
int last_shape = 0;
char_u *lasticon = NULL;
char_u *lasttitle = NULL;
int execreg_lastc = NUL;
struct spat saved_last_search_spat;
struct spat saved_spats [2];
int last_t_cmd = TRUE;
char_u lastc [2] = {NUL, NUL};
struct spat spats [2] = {{NULL, TRUE, FALSE, {'/', 0, 0, 0L}}, {NULL, TRUE, FALSE, {'/', 0, 0, 0L}}};
int last_set_cursor_blink = -1;
int last_set_cursor_shape = -1;
char_u *exe_path = NULL;
int last_breakp = 0;
int last_insert_skip;
char_u *last_insert = NULL;
hashtab_T compat_hashtab;
int include_groups = FALSE;
int last_group;
int current_augroup = AUGROUP_DEFAULT;
char_u *deleted_augroup = NULL;
garray_T augroups = {0, 0, sizeof (char_u *), 10, NULL};
msgchunk_T *last_msgchunk = NULL;
struct msg_hist *last_msg_hist = NULL;
int p_macatsui_last;
long  lastMouseTick = 0;
char_u e_pathtoolong [] = N_ ("E854: path too long for completion");
EXTERN unsigned  ve_flags;
EXTERN unsigned  vop_flags;
EXTERN unsigned  ttym_flags;
EXTERN unsigned  tbis_flags;
EXTERN unsigned  toolbar_flags;
EXTERN unsigned  tc_flags;
EXTERN unsigned  ssop_flags;
EXTERN unsigned  fuoptions_flags;
EXTERN unsigned  fdo_flags;
EXTERN unsigned  dy_flags;
EXTERN unsigned  bo_flags;
EXTERN unsigned  bkc_flags;
EXTERN char_u wim_flags [4];
EXTERN char breakat_flags [256];
char_u META_flags [] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1};
int sps_flags = SPS_BEST;
EXTERN char_u e_noprevre [] INIT (= N_ ("E35: No previous regular expression"));
EXTERN char_u e_noprev [] INIT (= N_ ("E34: No previous command"));
EXTERN win_T *prevwin INIT (= NULL);
struct timeval prev_timeval;
yankreg_T *y_previous = NULL;
char_u *prevcmd = NULL;
funccall_T *previous_funccal = NULL;
int prevprevchr;
int prevchr;
char_u *reg_prev_sub = NULL;
EXTERN int p_hls;
EXTERN char_u *p_hl;
EXTERN char_u *p_hlg;
EXTERN char_u e_positive [] INIT (= N_ ("E487: Argument must be positive"));
EXTERN hlf_T edit_submode_highl;
EXTERN int highlight_attr [HLF_COUNT];
float prt_pos_y = 0;
float prt_pos_x = 0;
float prt_pos_y_moveto = 0.0;
float prt_pos_x_moveto = 0.0;
int popup_mouse_pos;
XtExposeProc old_label_expose = NULL;
int *post_ptr;
int saved_no_hlsearch = 0;
int new_cmdpos;
match_T search_hl;
int out_pos = 0;
regsave_T behind_pos;
garray_T backpos = {0, 0, 0, 0, NULL};
int nextchr;
int runtimeidx;
const unsigned  char cmdidxs2 [26] [26] = {{0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 5, 6, 0, 0, 0, 7, 15, 0, 16, 0, 0, 0, 0, 0}, {2, 0, 0, 4, 5, 7, 0, 0, 0, 0, 0, 8, 9, 10, 11, 12, 0, 13, 0, 0, 0, 0, 22, 0, 0, 0}, {3, 10, 12, 14, 16, 18, 21, 0, 0, 0, 0, 29, 33, 36, 42, 51, 53, 54, 55, 0, 57, 0, 60, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 6, 15, 0, 16, 0, 0, 17, 0, 0, 19, 20, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 7, 9, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 0, 4, 5, 0, 0, 0, 0}, {5, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 3, 0, 0, 0, 4, 0, 5, 6, 0, 0, 0, 0, 0, 13, 0, 15, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {3, 9, 11, 15, 16, 20, 23, 28, 0, 0, 0, 30, 33, 36, 40, 46, 0, 48, 57, 49, 50, 54, 56, 0, 0, 0}, {1, 0, 0, 0, 9, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18}, {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 8, 10, 0, 0, 0, 0, 0, 17, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 5, 0, 0, 0, 0, 0, 0, 9, 0, 11, 0, 0, 0}, {1, 0, 3, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 9, 0, 0, 16, 17, 26, 0, 27, 0, 28, 0}, {2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 18, 0, 0, 0, 0}, {2, 6, 15, 0, 18, 22, 0, 24, 25, 0, 0, 28, 30, 34, 38, 40, 0, 48, 0, 49, 0, 61, 62, 0, 63, 0}, {2, 0, 19, 0, 22, 24, 0, 25, 0, 26, 0, 27, 28, 31, 33, 34, 0, 35, 37, 0, 38, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 1, 0, 0, 0, 4, 0, 0, 0, 9, 12, 0, 0, 0, 0, 15, 0, 16, 0, 0, 0, 0, 0}, {2, 0, 0, 0, 0, 0, 0, 3, 4, 0, 0, 0, 0, 8, 0, 9, 10, 0, 12, 0, 13, 14, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 5, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}};
const unsigned  short  cmdidxs1 [26] = {0, 19, 42, 103, 125, 145, 161, 167, 176, 194, 196, 201, 259, 279, 299, 311, 350, 353, 372, 439, 479, 490, 508, 523, 532, 533};
EXTERN int p_tbidi;
EXTERN int p_hid;
EXTERN char_u e_usingsid [] INIT (= N_ ("E81: Using <SID> not in a script context"));
EXTERN char_u e_listidx [] INIT (= N_ ("E684: list index out of range: %ld"));
EXTERN int ru_wid;
EXTERN int did_uncaught_emsg;
SPELL_EXTERN int did_set_spelltab;
int current_syn_id;
SharedFindReplace repl_widgets = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
SharedFindReplace find_widgets = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
const char * const menu_stock_ids [] = {GTK_STOCK_NEW, GTK_STOCK_OPEN, GTK_STOCK_SAVE, GTK_STOCK_UNDO, GTK_STOCK_REDO, GTK_STOCK_CUT, GTK_STOCK_COPY, GTK_STOCK_PASTE, GTK_STOCK_PRINT, GTK_STOCK_HELP, GTK_STOCK_FIND, "vim-save-all", "vim-session-save", "vim-session-new", "vim-session-load", GTK_STOCK_EXECUTE, GTK_STOCK_FIND_AND_REPLACE, GTK_STOCK_CLOSE, "vim-window-maximize", "vim-window-minimize", "vim-window-split", "vim-shell", GTK_STOCK_GO_BACK, GTK_STOCK_GO_FORWARD, "vim-find-help", GTK_STOCK_CONVERT, GTK_STOCK_JUMP_TO, "vim-build-tags", "vim-window-split-vertical", "vim-window-maximize-width", "vim-window-minimize-width", GTK_STOCK_QUIT};
int mshape_ids [] = {XC_left_ptr, 0, XC_xterm, XC_sb_v_double_arrow, XC_sizing, XC_sb_h_double_arrow, XC_sizing, XC_watch, XC_X_cursor, XC_crosshair, XC_hand1, XC_hand2, XC_pencil, XC_question_arrow, XC_right_ptr, XC_center_ptr, XC_left_ptr};
SharedFindReplace repl_widgets = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
SharedFindReplace find_widgets = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
int_u last_qf_id = 0;
int mshape_ids [] = {Ph_CURSOR_POINTER, Ph_CURSOR_NONE, Ph_CURSOR_INSERT, Ph_CURSOR_DRAG_VERTICAL, Ph_CURSOR_DRAG_VERTICAL, Ph_CURSOR_DRAG_HORIZONTAL, Ph_CURSOR_DRAG_HORIZONTAL, Ph_CURSOR_WAIT, Ph_CURSOR_DONT, Ph_CURSOR_CROSSHAIR, Ph_CURSOR_FINGER, Ph_CURSOR_FINGER, Ph_CURSOR_FINGER, Ph_CURSOR_QUESTION_POINT, Ph_CURSOR_POINTER, Ph_CURSOR_POINTER, Ph_CURSOR_POINTER};
WidgetClass vim_scrollbarWidgetClass = (WidgetClass) &vim_scrollbarClassRec;
void AllocBotShadowGC (Widget);
void AllocTopShadowGC (Widget);
void Resize (Widget);
void Destroy (Widget);
short  nv_cmd_idx [NV_CMDS_SIZE];
int nfa_alt_listid;
int nfa_listid;
int saved_last_idx = 0;
int last_idx = 0;
UINT s_menu_id = 100;
LPCSTR mshape_idcs [] = {IDC_ARROW, MAKEINTRESOURCE (0), IDC_IBEAM, IDC_SIZENS, IDC_SIZENS, IDC_SIZEWE, IDC_SIZEWE, IDC_WAIT, IDC_NO, IDC_ARROW, IDC_ARROW, IDC_ARROW, IDC_ARROW, IDC_ARROW, IDC_ARROW, IDC_UPARROW, IDC_ARROW};
int did_lcd;
int did_create_conin = FALSE;
int last_win_id = LOWEST_WIN_ID - 1;
long  last_timer_id = 0;
int next_ch_id = 0;
int did_log_msg = TRUE;
int did_add_space = FALSE;
int did_set_icon = FALSE;
int did_set_title = FALSE;
int verbose_did_open = FALSE;
EXTERN int modified_was_set;
int globalsignmapused = 0;
char **globalsignmap = NULL;
EXTERN pos_T where_paste_started;
VTermStateCallbacks state_cbs = {state_putglyph, movecursor, scrollrect, moverect, state_erase, NULL, state_setpenattr, settermprop, NULL, NULL, state_setlineinfo,};
int want_state_erase = 0;
int want_state_putglyph = 0;
VTermPos state_pos;
VTermState *state;
int blink_state = BLINK_NONE;
long  compress_start = 30000;
VTermStateCallbacks state_cbs = {&putglyph, &movecursor, &scrollrect, NULL, &erase, NULL, &setpenattr, &settermprop, &bell, &resize, &setlineinfo};
void *ruby_stack_start;
efm_T *fmt_start = NULL;
int restart_VIsual_select = 0;
nfa_state_T *state_ptr;
int istate;
int nstate;
int *post_start;
int nfa_nsubexpr;
int nfa_has_backref;
int blink_state = BLINK_NONE;
proftime_T log_start;
int did_restart_edit;
int update_Insstart_orig = TRUE;
pos_T compl_startpos;
int compl_started = FALSE;
lpos_T reg_startzpos [NSUBEXP];
char_u *reg_startzp [NSUBEXP];
int prev_at_start;
int at_start;
int nfa_re_flags;
int regexp_engine = 0;
regengine_T nfa_regengine = {nfa_regcomp, nfa_regfree, nfa_regexec_nl, nfa_regexec_multi, (char_u *) ""};
regengine_T bt_regengine = {bt_regcomp, bt_regfree, bt_regexec_nl, bt_regexec_multi, (char_u *) ""};
regengine_T nfa_regengine;
regengine_T bt_regengine;
unsigned  regflags;
const int command_count = 546;
EXTERN char_u e_zerocount [] INIT (= N_ ("E939: Positive count required"));
EXTERN char_u e_nomatch2 [] INIT (= N_ ("E480: No match: %s"));
EXTERN char_u e_nomatch [] INIT (= N_ ("E479: No match"));
EXTERN char_u *autocmd_match INIT (= NULL);
EXTERN reg_extmatch_T *re_extmatch_out INIT (= NULL);
EXTERN reg_extmatch_T *re_extmatch_in INIT (= NULL);
int page_count;
long  u_oldcount;
long  u_newcount;
int nfa_time_count;
int nfa_match;
pumitem_T *compl_match_array = NULL;
int compl_matches = 0;
int compl_used_match;
compl_T *compl_old_match = NULL;
compl_T *compl_shown_match = NULL;
compl_T *compl_curr_match = NULL;
compl_T *compl_first_match = NULL;
long  temp_count = 0;
long_u total_mem_used = 0;
int breakcheck_count = 0;
int can_f_submatch = FALSE;
int brace_count [10];
char_u e_unmatchedpar [] = N_ ("E55: Unmatched %s)");
char_u e_unmatchedp [] = N_ ("E54: Unmatched %s(");
char_u e_unmatchedpp [] = N_ ("E53: Unmatched %s%%(");
EXTERN unsigned  swb_flags;
EXTERN char_u e_bufloaded [] INIT (= N_ ("E139: File is loaded in another buffer"));
EXTERN char_u e_nobufnr [] INIT (= N_ ("E86: Buffer %ld does not exist"));
EXTERN char_u e_emptybuf [] INIT (= N_ ("E749: empty buffer"));
EXTERN char_u msg_buf [MSG_BUF_LEN];
EXTERN buf_T *curbuf INIT (= NULL);
EXTERN buf_T *lastbuf INIT (= NULL);
EXTERN buf_T *firstbuf INIT (= NULL);
int prt_bufsiz;
bufref_T qf_last_bufref = {NULL, 0, 0};
char_u old_showcmd_buf [SHOWCMD_BUFLEN];
char_u showcmd_buf [SHOWCMD_BUFLEN];
hashtab_T buf_hashtab;
int buf_free_count = 0;
char_u *arshape_buf = NULL;
int buf_list_used = 0;
nbbuf_T *buf_list = NULL;
buffheader_T readbuf2 = {{NULL, {NUL}}, NULL, 0, 0};
buffheader_T readbuf1 = {{NULL, {NUL}}, NULL, 0, 0};
char_u noremapbuf_init [TYPELEN_INIT];
char_u *sortbuf2;
char_u *sortbuf1;
char *e_auchangedbuf = N_ ("E812: Autocommands changed buffer or buffer name");
char_u out_buf [OUT_SIZE + 1];
char_u transchar_buf [7];
EXTERN char_u e_invalidreg [] INIT (= N_ ("E850: Invalid register name"));
int mr_pattern_alloced = FALSE;
char_u *mr_pattern = NULL;
int maphash_valid = FALSE;
char_u *compl_pattern = NULL;
linenr_T invalid_bot = (linenr_T) 0;
char installdir [BUFSIZE];
PyObject *py_fchdir;
PyObject *py_chdir;
EXTERN char_u *p_vdir;
EXTERN char_u *p_udir;
EXTERN long  p_linespace;
EXTERN char_u *p_dir;
EXTERN char_u *p_bdir;
EXTERN char_u e_dirnotf [] INIT (= N_ ("E919: Directory not found in '%s': \"%s\""));
EXTERN char_u e_prev_dir [] INIT (= N_ ("E459: Cannot go back to previous directory"));
EXTERN char_u e_isadir2 [] INIT (= N_ ("E17: \"%s\" is a directory"));
EXTERN char_u e_endfor [] INIT (= N_ ("E170: Missing :endfor"));
EXTERN char_u e_endwhile [] INIT (= N_ ("E170: Missing :endwhile"));
EXTERN char_u e_endtry [] INIT (= N_ ("E600: Missing :endtry"));
EXTERN char_u e_endif [] INIT (= N_ ("E171: Missing :endif"));
EXTERN char_u e_curdir [] INIT (= N_ ("E12: Command not allowed from exrc/vimrc in current dir or tag search"));
EXTERN linenr_T sub_nlines;
EXTERN char_u no_lines_msg [] INIT (= N_ ("--No lines in buffer--"));
EXTERN char_u *globaldir INIT (= NULL);
EXTERN FILE *redir_fd INIT (= NULL);
EXTERN char_u *repeat_cmdline INIT (= NULL);
EXTERN char_u *last_cmdline INIT (= NULL);
EXTERN char_u *vim_tempdir INIT (= NULL);
EXTERN win_T *au_pending_free_win INIT (= NULL);
EXTERN buf_T *au_pending_free_buf INIT (= NULL);
EXTERN linenr_T search_match_lines;
int prt_do_underline;
int prt_underline;
int prt_need_underline;
int curr_underline;
XrmOptionDescRec cmdline_options [] = {{"-bg", ".background", XrmoptionSepArg, NULL}, {"-background", ".background", XrmoptionSepArg, NULL}, {"-fg", ".foreground", XrmoptionSepArg, NULL}, {"-foreground", ".foreground", XrmoptionSepArg, NULL}, {"-fn", ".font", XrmoptionSepArg, NULL}, {"-font", ".font", XrmoptionSepArg, NULL}, {"-boldfont", ".boldFont", XrmoptionSepArg, NULL}, {"-italicfont", ".italicFont", XrmoptionSepArg, NULL}, {"-geom", ".geometry", XrmoptionSepArg, NULL}, {"-geometry", ".geometry", XrmoptionSepArg, NULL}, {"-reverse", "*reverseVideo", XrmoptionNoArg, "True"}, {"-rv", "*reverseVideo", XrmoptionNoArg, "True"}, {"+reverse", "*reverseVideo", XrmoptionNoArg, "False"}, {"+rv", "*reverseVideo", XrmoptionNoArg, "False"}, {"-display", ".display", XrmoptionSepArg, NULL}, {"-iconic", ".iconic", XrmoptionNoArg, "True"}, {"-name", ".name", XrmoptionSepArg, NULL}, {"-bw", ".borderWidth", XrmoptionSepArg, NULL}, {"-borderwidth", ".borderWidth", XrmoptionSepArg, NULL}, {"-sw", ".scrollbarWidth", XrmoptionSepArg, NULL}, {"-scrollbarwidth", ".scrollbarWidth", XrmoptionSepArg, NULL}, {"-mh", ".menuHeight", XrmoptionSepArg, NULL}, {"-menuheight", ".menuHeight", XrmoptionSepArg, NULL}, {"-mf", ".menuFont", XrmoptionSepArg, NULL}, {"-menufont", ".menuFont", XrmoptionSepArg, NULL}, {"-xrm", NULL, XrmoptionResArg, NULL}};
char_u *start_dir = NULL;
linenr_T resel_VIsual_line_count;
save_se_T *nfa_endp = NULL;
int *post_end;
int nfa_has_zend;
char_u *expr_line = NULL;
int y_append;
garray_T redir_execute_ga;
int lastcdir = FORWARD;
int prev_ccline_used = FALSE;
struct cmdline_info prev_ccline;
struct cmdline_info ccline;
int global_need_beginline;
int append_indent = 0;
int mouse_scroll_lines = 0;
UINT s_kFlags_pending;
int s_y_pending;
int s_x_pending;
int s_button_pending = -1;
char_u *prev_dir = NULL;
int compl_pending = 0;
int compl_shows_dir = FORWARD;
int compl_direction = FORWARD;
char e_hitend [] = N_ ("Hit end of paragraph");
int dont_check_job_ended = 0;
char_u *redir_endp = NULL;
garray_T redir_ga;
lval_T *redir_lval = NULL;
char_u *foldendmarker;
char_u *homedir = NULL;
lpos_T reg_endzpos [NSUBEXP];
char_u *reg_endzp [NSUBEXP];
char_u *regline;
char_u had_endbrace [NSUBEXP];
EXTERN except_T *caught_stack INIT (= NULL);
EXTERN except_T *current_exception;
EXTERN int did_emsg_syntax;
EXTERN int did_emsg;
event_T last_event;
EXTERN int p_altkeymap;
EXTERN char need_key_msg [] INIT (= N_ ("Need encryption key for \"%s\""));
EXTERN char_u e_dictkey [] INIT (= N_ ("E716: Key not present in Dictionary: %s"));
EXTERN char_u e_emptykey [] INIT (= N_ ("E713: Cannot use empty key for Dictionary"));
struct specialkey special_keys [] = {{XK_Up, 'k', 'u'}, {XK_Down, 'k', 'd'}, {XK_Left, 'k', 'l'}, {XK_Right, 'k', 'r'}, {XK_F1, 'k', '1'}, {XK_F2, 'k', '2'}, {XK_F3, 'k', '3'}, {XK_F4, 'k', '4'}, {XK_F5, 'k', '5'}, {XK_F6, 'k', '6'}, {XK_F7, 'k', '7'}, {XK_F8, 'k', '8'}, {XK_F9, 'k', '9'}, {XK_F10, 'k', ';'}, {XK_F11, 'F', '1'}, {XK_F12, 'F', '2'}, {XK_F13, 'F', '3'}, {XK_F14, 'F', '4'}, {XK_F15, 'F', '5'}, {XK_F16, 'F', '6'}, {XK_F17, 'F', '7'}, {XK_F18, 'F', '8'}, {XK_F19, 'F', '9'}, {XK_F20, 'F', 'A'}, {XK_F21, 'F', 'B'}, {XK_F22, 'F', 'C'}, {XK_F23, 'F', 'D'}, {XK_F24, 'F', 'E'}, {XK_F25, 'F', 'F'}, {XK_F26, 'F', 'G'}, {XK_F27, 'F', 'H'}, {XK_F28, 'F', 'I'}, {XK_F29, 'F', 'J'}, {XK_F30, 'F', 'K'}, {XK_F31, 'F', 'L'}, {XK_F32, 'F', 'M'}, {XK_F33, 'F', 'N'}, {XK_F34, 'F', 'O'}, {XK_F35, 'F', 'P'}, {XK_Help, '%', '1'}, {XK_Undo, '&', '8'}, {XK_BackSpace, 'k', 'b'}, {XK_Insert, 'k', 'I'}, {XK_Delete, 'k', 'D'}, {XK_Home, 'k', 'h'}, {XK_End, '@', '7'}, {XK_Prior, 'k', 'P'}, {XK_Next, 'k', 'N'}, {XK_Print, '%', '9'}, {(KeySym) 0, 0, 0}};
PtCallbackF_t gui_ph_handle_keyboard;
keyQ_T keyHead;
int dead_key = 0;
EventHandlerUPP keyEventHandlerUPP = NULL;
char_u modifier_keys_table [] = {MOD_MASK_SHIFT, '&', '9', '@', '1', MOD_MASK_SHIFT, '&', '0', '@', '2', MOD_MASK_SHIFT, '*', '1', '@', '4', MOD_MASK_SHIFT, '*', '2', '@', '5', MOD_MASK_SHIFT, '*', '3', '@', '6', MOD_MASK_SHIFT, '*', '4', 'k', 'D', MOD_MASK_SHIFT, '*', '5', 'k', 'L', MOD_MASK_SHIFT, '*', '7', '@', '7', MOD_MASK_CTRL, KS_EXTRA, (int) KE_C_END, '@', '7', MOD_MASK_SHIFT, '*', '9', '@', '9', MOD_MASK_SHIFT, '*', '0', '@', '0', MOD_MASK_SHIFT, '#', '1', '%', '1', MOD_MASK_SHIFT, '#', '2', 'k', 'h', MOD_MASK_CTRL, KS_EXTRA, (int) KE_C_HOME, 'k', 'h', MOD_MASK_SHIFT, '#', '3', 'k', 'I', MOD_MASK_SHIFT, '#', '4', 'k', 'l', MOD_MASK_CTRL, KS_EXTRA, (int) KE_C_LEFT, 'k', 'l', MOD_MASK_SHIFT, '%', 'a', '%', '3', MOD_MASK_SHIFT, '%', 'b', '%', '4', MOD_MASK_SHIFT, '%', 'c', '%', '5', MOD_MASK_SHIFT, '%', 'd', '%', '7', MOD_MASK_SHIFT, '%', 'e', '%', '8', MOD_MASK_SHIFT, '%', 'f', '%', '9', MOD_MASK_SHIFT, '%', 'g', '%', '0', MOD_MASK_SHIFT, '%', 'h', '&', '3', MOD_MASK_SHIFT, '%', 'i', 'k', 'r', MOD_MASK_CTRL, KS_EXTRA, (int) KE_C_RIGHT, 'k', 'r', MOD_MASK_SHIFT, '%', 'j', '&', '5', MOD_MASK_SHIFT, '!', '1', '&', '6', MOD_MASK_SHIFT, '!', '2', '&', '7', MOD_MASK_SHIFT, '!', '3', '&', '8', MOD_MASK_SHIFT, KS_EXTRA, (int) KE_S_UP, 'k', 'u', MOD_MASK_SHIFT, KS_EXTRA, (int) KE_S_DOWN, 'k', 'd', MOD_MASK_SHIFT, KS_EXTRA, (int) KE_S_XF1, KS_EXTRA, (int) KE_XF1, MOD_MASK_SHIFT, KS_EXTRA, (int) KE_S_XF2, KS_EXTRA, (int) KE_XF2, MOD_MASK_SHIFT, KS_EXTRA, (int) KE_S_XF3, KS_EXTRA, (int) KE_XF3, MOD_MASK_SHIFT, KS_EXTRA, (int) KE_S_XF4, KS_EXTRA, (int) KE_XF4, MOD_MASK_SHIFT, KS_EXTRA, (int) KE_S_F1, 'k', '1', MOD_MASK_SHIFT, KS_EXTRA, (int) KE_S_F2, 'k', '2', MOD_MASK_SHIFT, KS_EXTRA, (int) KE_S_F3, 'k', '3', MOD_MASK_SHIFT, KS_EXTRA, (int) KE_S_F4, 'k', '4', MOD_MASK_SHIFT, KS_EXTRA, (int) KE_S_F5, 'k', '5', MOD_MASK_SHIFT, KS_EXTRA, (int) KE_S_F6, 'k', '6', MOD_MASK_SHIFT, KS_EXTRA, (int) KE_S_F7, 'k', '7', MOD_MASK_SHIFT, KS_EXTRA, (int) KE_S_F8, 'k', '8', MOD_MASK_SHIFT, KS_EXTRA, (int) KE_S_F9, 'k', '9', MOD_MASK_SHIFT, KS_EXTRA, (int) KE_S_F10, 'k', ';', MOD_MASK_SHIFT, KS_EXTRA, (int) KE_S_F11, 'F', '1', MOD_MASK_SHIFT, KS_EXTRA, (int) KE_S_F12, 'F', '2', MOD_MASK_SHIFT, KS_EXTRA, (int) KE_S_F13, 'F', '3', MOD_MASK_SHIFT, KS_EXTRA, (int) KE_S_F14, 'F', '4', MOD_MASK_SHIFT, KS_EXTRA, (int) KE_S_F15, 'F', '5', MOD_MASK_SHIFT, KS_EXTRA, (int) KE_S_F16, 'F', '6', MOD_MASK_SHIFT, KS_EXTRA, (int) KE_S_F17, 'F', '7', MOD_MASK_SHIFT, KS_EXTRA, (int) KE_S_F18, 'F', '8', MOD_MASK_SHIFT, KS_EXTRA, (int) KE_S_F19, 'F', '9', MOD_MASK_SHIFT, KS_EXTRA, (int) KE_S_F20, 'F', 'A', MOD_MASK_SHIFT, KS_EXTRA, (int) KE_S_F21, 'F', 'B', MOD_MASK_SHIFT, KS_EXTRA, (int) KE_S_F22, 'F', 'C', MOD_MASK_SHIFT, KS_EXTRA, (int) KE_S_F23, 'F', 'D', MOD_MASK_SHIFT, KS_EXTRA, (int) KE_S_F24, 'F', 'E', MOD_MASK_SHIFT, KS_EXTRA, (int) KE_S_F25, 'F', 'F', MOD_MASK_SHIFT, KS_EXTRA, (int) KE_S_F26, 'F', 'G', MOD_MASK_SHIFT, KS_EXTRA, (int) KE_S_F27, 'F', 'H', MOD_MASK_SHIFT, KS_EXTRA, (int) KE_S_F28, 'F', 'I', MOD_MASK_SHIFT, KS_EXTRA, (int) KE_S_F29, 'F', 'J', MOD_MASK_SHIFT, KS_EXTRA, (int) KE_S_F30, 'F', 'K', MOD_MASK_SHIFT, KS_EXTRA, (int) KE_S_F31, 'F', 'L', MOD_MASK_SHIFT, KS_EXTRA, (int) KE_S_F32, 'F', 'M', MOD_MASK_SHIFT, KS_EXTRA, (int) KE_S_F33, 'F', 'N', MOD_MASK_SHIFT, KS_EXTRA, (int) KE_S_F34, 'F', 'O', MOD_MASK_SHIFT, KS_EXTRA, (int) KE_S_F35, 'F', 'P', MOD_MASK_SHIFT, KS_EXTRA, (int) KE_S_F36, 'F', 'Q', MOD_MASK_SHIFT, KS_EXTRA, (int) KE_S_F37, 'F', 'R', MOD_MASK_SHIFT, 'k', 'B', KS_EXTRA, (int) KE_TAB, NUL};
linenr_T debug_breakpoint_lnum;
int last_sourcing_lnum = 0;
int prev_lnum_lvl = -1;
linenr_T prev_lnum = 0;
linenr_T longest_lnum = 0;
linenr_T reglnum;
BufMapObject TheBufferMap = {PyObject_HEAD_INIT (&BufMapType)};
struct PyMethodDef BufferMethods [] = {{"append", (PyCFunction) BufferAppend, METH_VARARGS, "Append data to Vim buffer"}, {"mark", (PyCFunction) BufferMark, METH_O, "Return (row,col) representing position of named mark"}, {"range", (PyCFunction) BufferRange, METH_VARARGS, "Return a range object which represents the part of the given buffer between line numbers s and e"}, {"__dir__", (PyCFunction) BufferDir, METH_NOARGS, ""}, {NULL, NULL, 0, NULL}};
char *BufferAttrs [] = {"name", "number", "vars", "options", "valid", NULL};
EXTERN char_u *p_ffs;
EXTERN char_u *NameBuff;
EXTERN char_u *IObuff;
EXTERN unsigned  *LineOffset INIT (= NULL);
garray_T prt_ps_buffer;
char_u prt_line_buffer [257];
long_u blink_offtime = 250;
char *e_affrange = N_ ("E762: Character in FOL, LOW or UPP is out of range");
char *e_affform = N_ ("E761: Format error in affix file FOL, LOW or UPP");
char *e_afftrailing = N_ ("Trailing text in %s line %d: %s");
VALUE eDeletedBufferError;
VALUE cBuffer;
long_u blink_offtime = 250;
PhPoint_t gui_ph_raw_offset;
int expand_buffer = FALSE;
buffheader_T recordbuff = {{NULL, {NUL}}, NULL, 0, 0};
buffheader_T old_redobuff = {{NULL, {NUL}}, NULL, 0, 0};
buffheader_T redobuff = {{NULL, {NUL}}, NULL, 0, 0};
long_u blink_offtime = 250;
int diff_a_works = MAYBE;
int diff_flags = DIFF_FILLER;
int diff_busy = FALSE;
int cursor_is_off = FALSE;
int ta_off;
char_u *ff_file_to_find = NULL;
char_u *ff_expand_buffer = NULL;
EXTERN char bot_top_msg [] INIT (= N_ ("search hit BOTTOM, continuing at TOP"));
EXTERN char top_bot_msg [] INIT (= N_ ("search hit TOP, continuing at BOTTOM"));
EXTERN char_u e_maxmempat [] INIT (= N_ ("E363: pattern uses more memory than 'maxmempattern'"));
EXTERN char_u e_winwidth [] INIT (= N_ ("E592: 'winwidth' cannot be smaller than 'winminwidth'"));
EXTERN char_u e_winheight [] INIT (= N_ ("E591: 'winheight' cannot be smaller than 'winminheight'"));
EXTERN char_u e_notopen [] INIT (= N_ ("E484: Can't open file %s"));
EXTERN int stop_insert_mode;
EXTERN frame_T *topframe;
EXTERN long_u scrollbar_value;
float prt_number_width;
float prt_first_line_height;
float prt_line_height;
float prt_top_margin;
float prt_page_height;
float prt_page_width;
struct prt_mediasize_S prt_mediasize [] = {{"A4", 595.0, 842.0}, {"letter", 612.0, 792.0}, {"10x14", 720.0, 1008.0}, {"A3", 842.0, 1191.0}, {"A5", 420.0, 595.0}, {"B4", 729.0, 1032.0}, {"B5", 516.0, 729.0}, {"executive", 522.0, 756.0}, {"folio", 595.0, 935.0}, {"ledger", 1224.0, 792.0}, {"legal", 612.0, 1008.0}, {"quarto", 610.0, 780.0}, {"statement", 396.0, 612.0}, {"tabloid", 792.0, 1224.0}};
char_u *topmsg = (char_u *) N_ ("E556: at top of tag stack");
int current_font_height = -12;
PtCallbackF_t gui_ph_handle_menu_resize;
int puller_width = 0;
int nv_max_linear;
char *e_noident = N_ ("E349: No identifier under cursor");
int top_file_num = 1;
int cube_value [] = {0x00, 0x5F, 0x87, 0xAF, 0xD7, 0xFF};
int buf_list_size = 0;
WORD s_dlgfntwidth;
WORD s_dlgfntheight;
int suppress_winsize = 1;
int compl_match_arraysize;
volatile int do_resize = FALSE;
AutoPat *last_autopat [NUM_EVENTS] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
AutoPat *first_autopat [NUM_EVENTS] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
int size_set = FALSE;
linenr_T invalid_top = (linenr_T) 0;
int balloon_arraysize;
int pum_extra_width;
int pum_kind_width;
int pum_base_width;
int pum_width;
int pum_height;
int pum_size;
long  bl_maxval;
long  brace_max [10];
long  regsize;
char * (icon_link_names [ICON_COUNT]) = {"gVim " VIM_VERSION_SHORT ".lnk", "gVim Easy " VIM_VERSION_SHORT ".lnk", "gVim Read only " VIM_VERSION_SHORT ".lnk"};
char * (icon_names [ICON_COUNT]) = {"gVim " VIM_VERSION_SHORT, "gVim Easy " VIM_VERSION_SHORT, "gVim Read only " VIM_VERSION_SHORT};
int code_hdr_len = 30;
const char *code_hdr = "def " DOPY_FUNC "(line, linenr):\n ";
EXTERN long  p_titlelen;
EXTERN char_u e_longname [] INIT (= N_ ("E75: Name too long"));
EXTERN char_u e_noname [] INIT (= N_ ("E32: No file name"));
EXTERN int searchcmdlen;
EXTERN char_u *sourcing_name INIT (= NULL);
char_u *prt_ps_file_name = NULL;
char_u *tagmatchname = NULL;
char *mt_names [MT_COUNT / 2] = {"FSC", "F C", "F  ", "FS ", " SC", "  C", "   ", " S "};
char *pname;
int vi_jumplist_len = 0;
xfmark_T *vi_namedfm = NULL;
xfmark_T namedfm [NMARKS + EXTRA_MARKS];
char_u *altname_buf_ptr = NULL;
int nfa_classcodes [] = {NFA_ANY, NFA_IDENT, NFA_SIDENT, NFA_KWORD, NFA_SKWORD, NFA_FNAME, NFA_SFNAME, NFA_PRINT, NFA_SPRINT, NFA_WHITE, NFA_NWHITE, NFA_DIGIT, NFA_NDIGIT, NFA_HEX, NFA_NHEX, NFA_OCTAL, NFA_NOCTAL, NFA_WORD, NFA_NWORD, NFA_HEAD, NFA_NHEAD, NFA_ALPHA, NFA_NALPHA, NFA_LOWER, NFA_NLOWER, NFA_UPPER, NFA_NUPPER};
int globalsignmaplen = 0;
int last_recorded_len = 0;
const char *toolbar_names [] = {"New", "Open", "Save", "Undo", "Redo", "Cut", "Copy", "Paste", "Print", "Help", "Find", "SaveAll", "SaveSesn", "NewSesn", "LoadSesn", "RunScript", "Replace", "WinClose", "WinMax", "WinMin", "WinSplit", "Shell", "FindPrev", "FindNext", "FindHelp", "Make", "TagJump", "RunCtags", "WinVSplit", "WinMaxWidth", "WinMinWidth", "Exit"};
char_u *debug_skipped_name;
char_u *debug_breakpoint_name = NULL;
char *part_names [] = {"sock", "out", "err", "in"};
long  replace_stack_len = 0;
int spell_bad_len = 0;
int varnamebuflen = 0;
char_u *varnamebuf = NULL;
char_u *redir_varname = NULL;
struct event_name event_names [] = {{"BufAdd", EVENT_BUFADD}, {"BufCreate", EVENT_BUFADD}, {"BufDelete", EVENT_BUFDELETE}, {"BufEnter", EVENT_BUFENTER}, {"BufFilePost", EVENT_BUFFILEPOST}, {"BufFilePre", EVENT_BUFFILEPRE}, {"BufHidden", EVENT_BUFHIDDEN}, {"BufLeave", EVENT_BUFLEAVE}, {"BufNew", EVENT_BUFNEW}, {"BufNewFile", EVENT_BUFNEWFILE}, {"BufRead", EVENT_BUFREADPOST}, {"BufReadCmd", EVENT_BUFREADCMD}, {"BufReadPost", EVENT_BUFREADPOST}, {"BufReadPre", EVENT_BUFREADPRE}, {"BufUnload", EVENT_BUFUNLOAD}, {"BufWinEnter", EVENT_BUFWINENTER}, {"BufWinLeave", EVENT_BUFWINLEAVE}, {"BufWipeout", EVENT_BUFWIPEOUT}, {"BufWrite", EVENT_BUFWRITEPRE}, {"BufWritePost", EVENT_BUFWRITEPOST}, {"BufWritePre", EVENT_BUFWRITEPRE}, {"BufWriteCmd", EVENT_BUFWRITECMD}, {"CmdlineChanged", EVENT_CMDLINECHANGED}, {"CmdlineEnter", EVENT_CMDLINEENTER}, {"CmdlineLeave", EVENT_CMDLINELEAVE}, {"CmdwinEnter", EVENT_CMDWINENTER}, {"CmdwinLeave", EVENT_CMDWINLEAVE}, {"CmdUndefined", EVENT_CMDUNDEFINED}, {"ColorScheme", EVENT_COLORSCHEME}, {"CompleteDone", EVENT_COMPLETEDONE}, {"CursorHold", EVENT_CURSORHOLD}, {"CursorHoldI", EVENT_CURSORHOLDI}, {"CursorMoved", EVENT_CURSORMOVED}, {"CursorMovedI", EVENT_CURSORMOVEDI}, {"DirChanged", EVENT_DIRCHANGED}, {"EncodingChanged", EVENT_ENCODINGCHANGED}, {"FileEncoding", EVENT_ENCODINGCHANGED}, {"FileAppendPost", EVENT_FILEAPPENDPOST}, {"FileAppendPre", EVENT_FILEAPPENDPRE}, {"FileAppendCmd", EVENT_FILEAPPENDCMD}, {"FileChangedShell", EVENT_FILECHANGEDSHELL}, {"FileChangedShellPost", EVENT_FILECHANGEDSHELLPOST}, {"FileChangedRO", EVENT_FILECHANGEDRO}, {"FileReadPost", EVENT_FILEREADPOST}, {"FileReadPre", EVENT_FILEREADPRE}, {"FileReadCmd", EVENT_FILEREADCMD}, {"FileType", EVENT_FILETYPE}, {"FileWritePost", EVENT_FILEWRITEPOST}, {"FileWritePre", EVENT_FILEWRITEPRE}, {"FileWriteCmd", EVENT_FILEWRITECMD}, {"FilterReadPost", EVENT_FILTERREADPOST}, {"FilterReadPre", EVENT_FILTERREADPRE}, {"FilterWritePost", EVENT_FILTERWRITEPOST}, {"FilterWritePre", EVENT_FILTERWRITEPRE}, {"FocusGained", EVENT_FOCUSGAINED}, {"FocusLost", EVENT_FOCUSLOST}, {"FuncUndefined", EVENT_FUNCUNDEFINED}, {"GUIEnter", EVENT_GUIENTER}, {"GUIFailed", EVENT_GUIFAILED}, {"InsertChange", EVENT_INSERTCHANGE}, {"InsertEnter", EVENT_INSERTENTER}, {"InsertLeave", EVENT_INSERTLEAVE}, {"InsertCharPre", EVENT_INSERTCHARPRE}, {"MenuPopup", EVENT_MENUPOPUP}, {"OptionSet", EVENT_OPTIONSET}, {"QuickFixCmdPost", EVENT_QUICKFIXCMDPOST}, {"QuickFixCmdPre", EVENT_QUICKFIXCMDPRE}, {"QuitPre", EVENT_QUITPRE}, {"RemoteReply", EVENT_REMOTEREPLY}, {"SessionLoadPost", EVENT_SESSIONLOADPOST}, {"ShellCmdPost", EVENT_SHELLCMDPOST}, {"ShellFilterPost", EVENT_SHELLFILTERPOST}, {"SourcePre", EVENT_SOURCEPRE}, {"SourceCmd", EVENT_SOURCECMD}, {"SpellFileMissing", EVENT_SPELLFILEMISSING}, {"StdinReadPost", EVENT_STDINREADPOST}, {"StdinReadPre", EVENT_STDINREADPRE}, {"SwapExists", EVENT_SWAPEXISTS}, {"Syntax", EVENT_SYNTAX}, {"TabNew", EVENT_TABNEW}, {"TabClosed", EVENT_TABCLOSED}, {"TabEnter", EVENT_TABENTER}, {"TabLeave", EVENT_TABLEAVE}, {"TermChanged", EVENT_TERMCHANGED}, {"TermResponse", EVENT_TERMRESPONSE}, {"TextChanged", EVENT_TEXTCHANGED}, {"TextChangedI", EVENT_TEXTCHANGEDI}, {"TextChangedP", EVENT_TEXTCHANGEDP}, {"User", EVENT_USER}, {"VimEnter", EVENT_VIMENTER}, {"VimLeave", EVENT_VIMLEAVE}, {"VimLeavePre", EVENT_VIMLEAVEPRE}, {"WinNew", EVENT_WINNEW}, {"WinEnter", EVENT_WINENTER}, {"WinLeave", EVENT_WINLEAVE}, {"VimResized", EVENT_VIMRESIZED}, {"TextYankPost", EVENT_TEXTYANKPOST}, {NULL, (event_T) 0}};
char_u *last_sourcing_name = NULL;
int msg_hist_len = 0;
int id1_codes [] = {BLOCK0_ID1_C0, BLOCK0_ID1_C1, BLOCK0_ID1_C2,};
int foldendmarkerlen;
int foldstartmarkerlen;
int tc_len = 0;
int tc_max_len = 0;
int check_for_codes = FALSE;
int ta_len;
unsigned  reg_tofreelen;
int classcodes [] = {ANY, IDENT, SIDENT, KWORD, SKWORD, FNAME, SFNAME, PRINT, SPRINT, WHITE, NWHITE, DIGIT, NDIGIT, HEX, NHEX, OCTAL, NOCTAL, WORD, NWORD, HEAD, NHEAD, ALPHA, NALPHA, LOWER, NLOWER, UPPER, NUPPER};
char_u *regcode;
int prevchr_len;
struct key_name_entry key_names_table [] = {{' ', (char_u *) "Space"}, {TAB, (char_u *) "Tab"}, {K_TAB, (char_u *) "Tab"}, {NL, (char_u *) "NL"}, {NL, (char_u *) "NewLine"}, {NL, (char_u *) "LineFeed"}, {NL, (char_u *) "LF"}, {CAR, (char_u *) "CR"}, {CAR, (char_u *) "Return"}, {CAR, (char_u *) "Enter"}, {K_BS, (char_u *) "BS"}, {K_BS, (char_u *) "BackSpace"}, {ESC, (char_u *) "Esc"}, {CSI, (char_u *) "CSI"}, {K_CSI, (char_u *) "xCSI"}, {'|', (char_u *) "Bar"}, {'\\', (char_u *) "Bslash"}, {K_DEL, (char_u *) "Del"}, {K_DEL, (char_u *) "Delete"}, {K_KDEL, (char_u *) "kDel"}, {K_UP, (char_u *) "Up"}, {K_DOWN, (char_u *) "Down"}, {K_LEFT, (char_u *) "Left"}, {K_RIGHT, (char_u *) "Right"}, {K_XUP, (char_u *) "xUp"}, {K_XDOWN, (char_u *) "xDown"}, {K_XLEFT, (char_u *) "xLeft"}, {K_XRIGHT, (char_u *) "xRight"}, {K_PS, (char_u *) "PasteStart"}, {K_PE, (char_u *) "PasteEnd"}, {K_F1, (char_u *) "F1"}, {K_F2, (char_u *) "F2"}, {K_F3, (char_u *) "F3"}, {K_F4, (char_u *) "F4"}, {K_F5, (char_u *) "F5"}, {K_F6, (char_u *) "F6"}, {K_F7, (char_u *) "F7"}, {K_F8, (char_u *) "F8"}, {K_F9, (char_u *) "F9"}, {K_F10, (char_u *) "F10"}, {K_F11, (char_u *) "F11"}, {K_F12, (char_u *) "F12"}, {K_F13, (char_u *) "F13"}, {K_F14, (char_u *) "F14"}, {K_F15, (char_u *) "F15"}, {K_F16, (char_u *) "F16"}, {K_F17, (char_u *) "F17"}, {K_F18, (char_u *) "F18"}, {K_F19, (char_u *) "F19"}, {K_F20, (char_u *) "F20"}, {K_F21, (char_u *) "F21"}, {K_F22, (char_u *) "F22"}, {K_F23, (char_u *) "F23"}, {K_F24, (char_u *) "F24"}, {K_F25, (char_u *) "F25"}, {K_F26, (char_u *) "F26"}, {K_F27, (char_u *) "F27"}, {K_F28, (char_u *) "F28"}, {K_F29, (char_u *) "F29"}, {K_F30, (char_u *) "F30"}, {K_F31, (char_u *) "F31"}, {K_F32, (char_u *) "F32"}, {K_F33, (char_u *) "F33"}, {K_F34, (char_u *) "F34"}, {K_F35, (char_u *) "F35"}, {K_F36, (char_u *) "F36"}, {K_F37, (char_u *) "F37"}, {K_XF1, (char_u *) "xF1"}, {K_XF2, (char_u *) "xF2"}, {K_XF3, (char_u *) "xF3"}, {K_XF4, (char_u *) "xF4"}, {K_HELP, (char_u *) "Help"}, {K_UNDO, (char_u *) "Undo"}, {K_INS, (char_u *) "Insert"}, {K_INS, (char_u *) "Ins"}, {K_KINS, (char_u *) "kInsert"}, {K_HOME, (char_u *) "Home"}, {K_KHOME, (char_u *) "kHome"}, {K_XHOME, (char_u *) "xHome"}, {K_ZHOME, (char_u *) "zHome"}, {K_END, (char_u *) "End"}, {K_KEND, (char_u *) "kEnd"}, {K_XEND, (char_u *) "xEnd"}, {K_ZEND, (char_u *) "zEnd"}, {K_PAGEUP, (char_u *) "PageUp"}, {K_PAGEDOWN, (char_u *) "PageDown"}, {K_KPAGEUP, (char_u *) "kPageUp"}, {K_KPAGEDOWN, (char_u *) "kPageDown"}, {K_KPLUS, (char_u *) "kPlus"}, {K_KMINUS, (char_u *) "kMinus"}, {K_KDIVIDE, (char_u *) "kDivide"}, {K_KMULTIPLY, (char_u *) "kMultiply"}, {K_KENTER, (char_u *) "kEnter"}, {K_KPOINT, (char_u *) "kPoint"}, {K_K0, (char_u *) "k0"}, {K_K1, (char_u *) "k1"}, {K_K2, (char_u *) "k2"}, {K_K3, (char_u *) "k3"}, {K_K4, (char_u *) "k4"}, {K_K5, (char_u *) "k5"}, {K_K6, (char_u *) "k6"}, {K_K7, (char_u *) "k7"}, {K_K8, (char_u *) "k8"}, {K_K9, (char_u *) "k9"}, {'<', (char_u *) "lt"}, {K_MOUSE, (char_u *) "Mouse"}, {K_NETTERM_MOUSE, (char_u *) "NetMouse"}, {K_DEC_MOUSE, (char_u *) "DecMouse"}, {K_URXVT_MOUSE, (char_u *) "UrxvtMouse"}, {K_SGR_MOUSE, (char_u *) "SgrMouse"}, {K_SGR_MOUSERELEASE, (char_u *) "SgrMouseRelelase"}, {K_LEFTMOUSE, (char_u *) "LeftMouse"}, {K_LEFTMOUSE_NM, (char_u *) "LeftMouseNM"}, {K_LEFTDRAG, (char_u *) "LeftDrag"}, {K_LEFTRELEASE, (char_u *) "LeftRelease"}, {K_LEFTRELEASE_NM, (char_u *) "LeftReleaseNM"}, {K_MOUSEMOVE, (char_u *) "MouseMove"}, {K_MIDDLEMOUSE, (char_u *) "MiddleMouse"}, {K_MIDDLEDRAG, (char_u *) "MiddleDrag"}, {K_MIDDLERELEASE, (char_u *) "MiddleRelease"}, {K_RIGHTMOUSE, (char_u *) "RightMouse"}, {K_RIGHTDRAG, (char_u *) "RightDrag"}, {K_RIGHTRELEASE, (char_u *) "RightRelease"}, {K_MOUSEDOWN, (char_u *) "ScrollWheelUp"}, {K_MOUSEUP, (char_u *) "ScrollWheelDown"}, {K_MOUSELEFT, (char_u *) "ScrollWheelRight"}, {K_MOUSERIGHT, (char_u *) "ScrollWheelLeft"}, {K_MOUSEDOWN, (char_u *) "MouseDown"}, {K_MOUSEUP, (char_u *) "MouseUp"}, {K_X1MOUSE, (char_u *) "X1Mouse"}, {K_X1DRAG, (char_u *) "X1Drag"}, {K_X1RELEASE, (char_u *) "X1Release"}, {K_X2MOUSE, (
  char_u *) "X2Mouse"}, {K_X2DRAG, (char_u *) "X2Drag"}, {K_X2RELEASE, (char_u *) "X2Release"}, {K_DROP, (char_u *) "Drop"}, {K_ZERO, (char_u *) "Nul"}, {K_SNR, (char_u *) "SNR"}, {K_PLUG, (char_u *) "Plug"}, {K_CURSORHOLD, (char_u *) "CursorHold"}, {K_SWIPELEFT, (char_u *) "SwipeLeft"}, {K_SWIPERIGHT, (char_u *) "SwipeRight"}, {K_SWIPEUP, (char_u *) "SwipeUp"}, {K_SWIPEDOWN, (char_u *) "SwipeDown"}, {0, NULL}};
char_u *username = NULL;
EXTERN pos_T Insstart_orig;
EXTERN pos_T Insstart;
EXTERN pos_T VIsual;
int allow_scrollbar = FALSE;
int show_shell_mess = TRUE;
int allow_scrollbar = FALSE;
EXTERN int p_cc_cols [256];
EXTERN long  p_columnspace;
EXTERN int fuoptions_bgcolor;
EXTERN int arrow_used;
EXTERN int sc_col;
EXTERN int ru_col;
EXTERN int mouse_col;
EXTERN int mouse_row;
EXTERN colnr_T search_match_endcol;
EXTERN int msg_row;
EXTERN int msg_col;
EXTERN int cmdline_row;
int prt_collate;
int prt_new_bgcol;
int prt_bgcol;
int prt_do_bgcol;
int prt_need_bgcol;
int prt_fgcol;
int prt_need_fgcol;
float prt_bgcol_offset;
float prt_char_width;
const VTermColor ansi_colors [] = {{0, 0, 0, 1}, {224, 0, 0, 2}, {0, 224, 0, 3}, {224, 224, 0, 4}, {0, 0, 224, 5}, {224, 0, 224, 6}, {0, 224, 224, 7}, {224, 224, 224, 8}, {128, 128, 128, 9}, {255, 64, 64, 10}, {64, 255, 64, 11}, {255, 255, 64, 12}, {64, 64, 255, 13}, {255, 64, 255, 14}, {64, 255, 255, 15}, {255, 255, 255, 16},};
guicolor_T prev_sp_color = INVALCOLOR;
guicolor_T prev_bg_color = INVALCOLOR;
guicolor_T prev_fg_color = INVALCOLOR;
PgColor_t gui_ph_mouse_color = Pg_BLACK;
colnr_T resel_VIsual_vcol;
char_u *desired_cursor_color = (char_u *) "";
char_u *last_set_cursor_color = (char_u *) "";
char *ExtEdProtocolVersion = "2.5";
int old_mouse_col;
int old_mouse_row;
int screen_cur_col;
int screen_cur_row;
int pc_col;
int pc_row;
int revins_scol;
colnr_T Insstart_blank_vcol;
colnr_T Insstart_textlen;
colnr_T compl_col = 0;
int compl_restarting = FALSE;
int balloon_mouse_col = 0;
int balloon_mouse_row = 0;
int pum_col;
int pum_row;
int prev_which_scrollbars [3];
ControlHandle dragged_sb = NULL;
int rex_in_use = FALSE;
EXTERN int p_bevalterm;
EXTERN char_u e_invargval [] INIT (= N_ ("E475: Invalid value for argument %s"));
EXTERN int autocmd_fname_full;
EXTERN char_u *autocmd_fname INIT (= NULL);
int want_settermprop = 0;
const long_u cterm_color_16 [16] = {(long_u) 0x000000L, (long_u) 0x0000c0L, (long_u) 0x008000L, (long_u) 0x004080L, (long_u) 0xc00000L, (long_u) 0xc000c0L, (long_u) 0x808000L, (long_u) 0xc0c0c0L, (long_u) 0x808080L, (long_u) 0x6060ffL, (long_u) 0x00ff00L, (long_u) 0x00ffffL, (long_u) 0xff8080L, (long_u) 0xff40ffL, (long_u) 0xffff00L, (long_u) 0xffffffL};
const long_u cterm_color_8 [8] = {(long_u) 0x000000L, (long_u) 0xff0000L, (long_u) 0x00ff00L, (long_u) 0xffff00L, (long_u) 0x0000ffL, (long_u) 0xff00ffL, (long_u) 0x00ffffL, (long_u) 0xffffffL};
garray_T tag_fnames = GA_EMPTY;
char_u *nofile_fname = NULL;
char **gui_argv = NULL;
int gui_argc = 0;
char *e_affname = N_ ("Affix name too long in %s line %d: %s");
char_u *qf_last_bufname = NULL;
int term_default_cterm_bg = -1;
int term_default_cterm_fg = -1;
int term_backspace_char = BS;
term_T *in_terminal_loop = NULL;
term_T *first_term = NULL;
char_u *profile_fname = NULL;
char_u *old_termresponse = NULL;
struct termcode *termcodes = NULL;
int is_not_xterm = FALSE;
char_u termleader [256 + 1];
char_u * (term_strings [(int) KS_LAST + 1]);
EXTERN typebuf_T typebuf;
char *prt_resource_types [] = {"procset", "encoding", "cmap"};
int curPCtype = -1;
typebuf_T saved_typebuf [NSCRIPT];
char_u typebuf_init [TYPELEN_INIT];
int typeahead_char = 0;
int next_sign_typenr = 1;
int filetype_indent = FALSE;
int filetype_plugin = FALSE;
int filetype_detect = FALSE;
EXTERN vimmenu_T *root_menu INIT (= NULL);
EXTERN long  Rows;
EXTERN char_u *p_guifont;
EXTERN char *font_argument INIT (= NULL);
EXTERN int msg_scrolled;
EventHandlerUPP mouseWheelHandlerUPP = NULL;
SInt32 gMacSystemVersion;
EXTERN int p_secure;
EXTERN int p_exrc;
EXTERN char_u *use_gvimrc INIT (= NULL);
struct builtin_term builtin_termcaps [] = {{(int) KS_NAME, "gui"}, {(int) KS_CE, IF_EB ("\033|$", ESC_STR "|$")}, {(int) KS_AL, IF_EB ("\033|i", ESC_STR "|i")}, {(int) KS_CAL, IF_EB ("\033|%p1%dI", ESC_STR "|%p1%dI")}, {(int) KS_DL, IF_EB ("\033|d", ESC_STR "|d")}, {(int) KS_CDL, IF_EB ("\033|%p1%dD", ESC_STR "|%p1%dD")}, {(int) KS_CS, IF_EB ("\033|%p1%d;%p2%dR", ESC_STR "|%p1%d;%p2%dR")}, {(int) KS_CSV, IF_EB ("\033|%p1%d;%p2%dV", ESC_STR "|%p1%d;%p2%dV")}, {(int) KS_CL, IF_EB ("\033|C", ESC_STR "|C")}, {(int) KS_ME, IF_EB ("\033|31H", ESC_STR "|31H")}, {(int) KS_MR, IF_EB ("\033|1h", ESC_STR "|1h")}, {(int) KS_MD, IF_EB ("\033|2h", ESC_STR "|2h")}, {(int) KS_SE, IF_EB ("\033|16H", ESC_STR "|16H")}, {(int) KS_SO, IF_EB ("\033|16h", ESC_STR "|16h")}, {(int) KS_UE, IF_EB ("\033|8H", ESC_STR "|8H")}, {(int) KS_US, IF_EB ("\033|8h", ESC_STR "|8h")}, {(int) KS_UCE, IF_EB ("\033|8C", ESC_STR "|8C")}, {(int) KS_UCS, IF_EB ("\033|8c", ESC_STR "|8c")}, {(int) KS_STE, IF_EB ("\033|4C", ESC_STR "|4C")}, {(int) KS_STS, IF_EB ("\033|4c", ESC_STR "|4c")}, {(int) KS_CZR, IF_EB ("\033|4H", ESC_STR "|4H")}, {(int) KS_CZH, IF_EB ("\033|4h", ESC_STR "|4h")}, {(int) KS_VB, IF_EB ("\033|f", ESC_STR "|f")}, {(int) KS_MS, "y"}, {(int) KS_UT, "y"}, {(int) KS_XN, "y"}, {(int) KS_LE, "\b"}, {(int) KS_ND, "\014"}, {(int) KS_CM, IF_EB ("\033|%p1%d;%p2%dM", ESC_STR "|%p1%d;%p2%dM")}, {(int) KS_NAME, "ansi"}, {(int) KS_CE, IF_EB ("\033[K", ESC_STR "[K")}, {(int) KS_AL, IF_EB ("\033[L", ESC_STR "[L")}, {(int) KS_CAL, IF_EB ("\033[%p1%dL", ESC_STR "[%p1%dL")}, {(int) KS_DL, IF_EB ("\033[M", ESC_STR "[M")}, {(int) KS_CDL, IF_EB ("\033[%p1%dM", ESC_STR "[%p1%dM")}, {(int) KS_CL, IF_EB ("\033[H\033[2J", ESC_STR "[H" ESC_STR_nc "[2J")}, {(int) KS_ME, IF_EB ("\033[0m", ESC_STR "[0m")}, {(int) KS_MR, IF_EB ("\033[7m", ESC_STR "[7m")}, {(int) KS_MS, "y"}, {(int) KS_UT, "y"}, {(int) KS_LE, "\b"}, {(int) KS_CM, IF_EB ("\033[%i%p1%d;%p2%dH", ESC_STR "[%i%p1%d;%p2%dH")}, {(int) KS_CRI, IF_EB ("\033[%p1%dC", ESC_STR "[%p1%dC")}, {(int) KS_NAME, "xterm"}, {(int) KS_CE, IF_EB ("\033[K", ESC_STR "[K")}, {(int) KS_AL, IF_EB ("\033[L", ESC_STR "[L")}, {(int) KS_CAL, IF_EB ("\033[%p1%dL", ESC_STR "[%p1%dL")}, {(int) KS_DL, IF_EB ("\033[M", ESC_STR "[M")}, {(int) KS_CDL, IF_EB ("\033[%p1%dM", ESC_STR "[%p1%dM")}, {(int) KS_CS, IF_EB ("\033[%i%p1%d;%p2%dr", ESC_STR "[%i%p1%d;%p2%dr")}, {(int) KS_CL, IF_EB ("\033[H\033[2J", ESC_STR "[H" ESC_STR_nc "[2J")}, {(int) KS_CD, IF_EB ("\033[J", ESC_STR "[J")}, {(int) KS_ME, IF_EB ("\033[m", ESC_STR "[m")}, {(int) KS_MR, IF_EB ("\033[7m", ESC_STR "[7m")}, {(int) KS_MD, IF_EB ("\033[1m", ESC_STR "[1m")}, {(int) KS_UE, IF_EB ("\033[m", ESC_STR "[m")}, {(int) KS_US, IF_EB ("\033[4m", ESC_STR "[4m")}, {(int) KS_STE, IF_EB ("\033[29m", ESC_STR "[29m")}, {(int) KS_STS, IF_EB ("\033[9m", ESC_STR "[9m")}, {(int) KS_MS, "y"}, {(int) KS_UT, "y"}, {(int) KS_LE, "\b"}, {(int) KS_VI, IF_EB ("\033[?25l", ESC_STR "[?25l")}, {(int) KS_VE, IF_EB ("\033[?25h", ESC_STR "[?25h")}, {(int) KS_VS, IF_EB ("\033[?12h", ESC_STR "[?12h")}, {(int) KS_CVS, IF_EB ("\033[?12l", ESC_STR "[?12l")}, {(int) KS_CSH, IF_EB ("\033[%p1%d q", ESC_STR "[%p1%d q")}, {(int) KS_CRC, IF_EB ("\033[?12$p", ESC_STR "[?12$p")}, {(int) KS_CRS, IF_EB ("\033P$q q\033\\", ESC_STR "P$q q" ESC_STR "\\")}, {(int) KS_CM, IF_EB ("\033[%i%p1%d;%p2%dH", ESC_STR "[%i%p1%d;%p2%dH")}, {(int) KS_SR, IF_EB ("\033M", ESC_STR "M")}, {(int) KS_CRI, IF_EB ("\033[%p1%dC", ESC_STR "[%p1%dC")}, {(int) KS_KS, IF_EB ("\033[?1h\033=", ESC_STR "[?1h" ESC_STR_nc "=")}, {(int) KS_KE, IF_EB ("\033[?1l\033>", ESC_STR "[?1l" ESC_STR_nc ">")}, {(int) KS_CIS, IF_EB ("\033]1;", ESC_STR "]1;")}, {(int) KS_CIE, "\007"}, {(int) KS_TS, IF_EB ("\033]2;", ESC_STR "]2;")}, {(int) KS_FS, "\007"}, {(int) KS_CSC, IF_EB ("\033]12;", ESC_STR "]12;")}, {(int) KS_CEC, "\007"}, {(int) KS_CWS, IF_EB ("\033[8;%p1%d;%p2%dt", ESC_STR "[8;%p1%d;%p2%dt")}, {(int) KS_CWP, IF_EB ("\033[3;%p1%d;%p2%dt", ESC_STR "[3;%p1%d;%p2%dt")}, {(int) KS_CGP, IF_EB ("\033[13t", ESC_STR "[13t")}, {(int) KS_CRV, IF_EB ("\033[>c", ESC_STR "[>c")}, {(
  int) KS_RFG, IF_EB ("\033]10;?\007", ESC_STR "]10;?\007")}, {(int) KS_RBG, IF_EB ("\033]11;?\007", ESC_STR "]11;?\007")}, {(int) KS_U7, IF_EB ("\033[6n", ESC_STR "[6n")}, {(int) KS_8F, IF_EB ("\033[38;2;%lu;%lu;%lum", ESC_STR "[38;2;%lu;%lu;%lum")}, {(int) KS_8B, IF_EB ("\033[48;2;%lu;%lu;%lum", ESC_STR "[48;2;%lu;%lu;%lum")}, {(int) KS_CBE, IF_EB ("\033[?2004h", ESC_STR "[?2004h")}, {(int) KS_CBD, IF_EB ("\033[?2004l", ESC_STR "[?2004l")}, {K_UP, IF_EB ("\033O*A", ESC_STR "O*A")}, {K_DOWN, IF_EB ("\033O*B", ESC_STR "O*B")}, {K_RIGHT, IF_EB ("\033O*C", ESC_STR "O*C")}, {K_LEFT, IF_EB ("\033O*D", ESC_STR "O*D")}, {K_XUP, IF_EB ("\033[1;*A", ESC_STR "[1;*A")}, {K_XDOWN, IF_EB ("\033[1;*B", ESC_STR "[1;*B")}, {K_XRIGHT, IF_EB ("\033[1;*C", ESC_STR "[1;*C")}, {K_XLEFT, IF_EB ("\033[1;*D", ESC_STR "[1;*D")}, {K_XF1, IF_EB ("\033O*P", ESC_STR "O*P")}, {K_XF2, IF_EB ("\033O*Q", ESC_STR "O*Q")}, {K_XF3, IF_EB ("\033O*R", ESC_STR "O*R")}, {K_XF4, IF_EB ("\033O*S", ESC_STR "O*S")}, {K_F1, IF_EB ("\033[11;*~", ESC_STR "[11;*~")}, {K_F2, IF_EB ("\033[12;*~", ESC_STR "[12;*~")}, {K_F3, IF_EB ("\033[13;*~", ESC_STR "[13;*~")}, {K_F4, IF_EB ("\033[14;*~", ESC_STR "[14;*~")}, {K_F5, IF_EB ("\033[15;*~", ESC_STR "[15;*~")}, {K_F6, IF_EB ("\033[17;*~", ESC_STR "[17;*~")}, {K_F7, IF_EB ("\033[18;*~", ESC_STR "[18;*~")}, {K_F8, IF_EB ("\033[19;*~", ESC_STR "[19;*~")}, {K_F9, IF_EB ("\033[20;*~", ESC_STR "[20;*~")}, {K_F10, IF_EB ("\033[21;*~", ESC_STR "[21;*~")}, {K_F11, IF_EB ("\033[23;*~", ESC_STR "[23;*~")}, {K_F12, IF_EB ("\033[24;*~", ESC_STR "[24;*~")}, {K_S_TAB, IF_EB ("\033[Z", ESC_STR "[Z")}, {K_HELP, IF_EB ("\033[28;*~", ESC_STR "[28;*~")}, {K_UNDO, IF_EB ("\033[26;*~", ESC_STR "[26;*~")}, {K_INS, IF_EB ("\033[2;*~", ESC_STR "[2;*~")}, {K_HOME, IF_EB ("\033[1;*H", ESC_STR "[1;*H")}, {K_KHOME, IF_EB ("\033[1;*~", ESC_STR "[1;*~")}, {K_XHOME, IF_EB ("\033O*H", ESC_STR "O*H")}, {K_ZHOME, IF_EB ("\033[7;*~", ESC_STR "[7;*~")}, {K_END, IF_EB ("\033[1;*F", ESC_STR "[1;*F")}, {K_KEND, IF_EB ("\033[4;*~", ESC_STR "[4;*~")}, {K_XEND, IF_EB ("\033O*F", ESC_STR "O*F")}, {K_ZEND, IF_EB ("\033[8;*~", ESC_STR "[8;*~")}, {K_PAGEUP, IF_EB ("\033[5;*~", ESC_STR "[5;*~")}, {K_PAGEDOWN, IF_EB ("\033[6;*~", ESC_STR "[6;*~")}, {K_KPLUS, IF_EB ("\033O*k", ESC_STR "O*k")}, {K_KMINUS, IF_EB ("\033O*m", ESC_STR "O*m")}, {K_KDIVIDE, IF_EB ("\033O*o", ESC_STR "O*o")}, {K_KMULTIPLY, IF_EB ("\033O*j", ESC_STR "O*j")}, {K_KENTER, IF_EB ("\033O*M", ESC_STR "O*M")}, {K_KPOINT, IF_EB ("\033O*n", ESC_STR "O*n")}, {K_KDEL, IF_EB ("\033[3;*~", ESC_STR "[3;*~")}, {K_PS, IF_EB ("\033[200~", ESC_STR "[200~")}, {K_PE, IF_EB ("\033[201~", ESC_STR "[201~")}, {BT_EXTRA_KEYS, ""}, {TERMCAP2KEY ('k', '0'), IF_EB ("\033[10;*~", ESC_STR "[10;*~")}, {TERMCAP2KEY ('F', '3'), IF_EB ("\033[25;*~", ESC_STR "[25;*~")}, {TERMCAP2KEY ('F', '6'), IF_EB ("\033[29;*~", ESC_STR "[29;*~")}, {TERMCAP2KEY ('F', '7'), IF_EB ("\033[31;*~", ESC_STR "[31;*~")}, {TERMCAP2KEY ('F', '8'), IF_EB ("\033[32;*~", ESC_STR "[32;*~")}, {TERMCAP2KEY ('F', '9'), IF_EB ("\033[33;*~", ESC_STR "[33;*~")}, {TERMCAP2KEY ('F', 'A'), IF_EB ("\033[34;*~", ESC_STR "[34;*~")}, {TERMCAP2KEY ('F', 'B'), IF_EB ("\033[42;*~", ESC_STR "[42;*~")}, {TERMCAP2KEY ('F', 'C'), IF_EB ("\033[43;*~", ESC_STR "[43;*~")}, {TERMCAP2KEY ('F', 'D'), IF_EB ("\033[44;*~", ESC_STR "[44;*~")}, {TERMCAP2KEY ('F', 'E'), IF_EB ("\033[45;*~", ESC_STR "[45;*~")}, {TERMCAP2KEY ('F', 'F'), IF_EB ("\033[46;*~", ESC_STR "[46;*~")}, {TERMCAP2KEY ('F', 'G'), IF_EB ("\033[47;*~", ESC_STR "[47;*~")}, {TERMCAP2KEY ('F', 'H'), IF_EB ("\033[48;*~", ESC_STR "[48;*~")}, {TERMCAP2KEY ('F', 'I'), IF_EB ("\033[49;*~", ESC_STR "[49;*~")}, {TERMCAP2KEY ('F', 'J'), IF_EB ("\033[50;*~", ESC_STR "[50;*~")}, {TERMCAP2KEY ('F', 'K'), IF_EB ("\033[51;*~", ESC_STR "[51;*~")}, {TERMCAP2KEY ('F', 'L'), IF_EB ("\033[52;*~", ESC_STR "[52;*~")}, {TERMCAP2KEY ('F', 'M'), IF_EB ("\033[53;*~", ESC_STR "[53;*~")}, {TERMCAP2KEY ('F', 'N'), IF_EB ("\033[54;*~", ESC_STR "[54;*~")}, {TERMCAP2KEY ('F', 'O'), IF_EB ("\033[55;*~", ESC_STR "[55;*~")}, {TERMCAP2KEY ('F', 'P'), IF_EB 
  ("\033[56;*~", ESC_STR "[56;*~")}, {TERMCAP2KEY ('F', 'Q'), IF_EB ("\033[57;*~", ESC_STR "[57;*~")}, {TERMCAP2KEY ('F', 'R'), IF_EB ("\033[58;*~", ESC_STR "[58;*~")}, {(int) KS_NAME, "iris-ansi"}, {(int) KS_CE, "\033[K"}, {(int) KS_CD, "\033[J"}, {(int) KS_AL, "\033[L"}, {(int) KS_CAL, "\033[%p1%dL"}, {(int) KS_DL, "\033[M"}, {(int) KS_CDL, "\033[%p1%dM"}, {(int) KS_CL, "\033[H\033[2J"}, {(int) KS_VE, "\033[9/y\033[12/y"}, {(int) KS_VS, "\033[10/y\033[=1h\033[=2l"}, {(int) KS_TI, "\033[=6h"}, {(int) KS_TE, "\033[=6l"}, {(int) KS_SE, "\033[21;27m"}, {(int) KS_SO, "\033[1;7m"}, {(int) KS_ME, "\033[m"}, {(int) KS_MR, "\033[7m"}, {(int) KS_MD, "\033[1m"}, {(int) KS_CCO, "8"}, {(int) KS_CZH, "\033[3m"}, {(int) KS_CZR, "\033[23m"}, {(int) KS_US, "\033[4m"}, {(int) KS_UE, "\033[24m"}, {(int) KS_CAB, "\033[4%p1%dm"}, {(int) KS_CAF, "\033[3%p1%dm"}, {(int) KS_CSB, "\033[102;%p1%dm"}, {(int) KS_CSF, "\033[101;%p1%dm"}, {(int) KS_MS, "y"}, {(int) KS_UT, "y"}, {(int) KS_LE, "\b"}, {(int) KS_CM, "\033[%i%p1%d;%p2%dH"}, {(int) KS_SR, "\033M"}, {(int) KS_CRI, "\033[%p1%dC"}, {(int) KS_CIS, "\033P3.y"}, {(int) KS_CIE, "\234"}, {(int) KS_TS, "\033P1.y"}, {(int) KS_FS, "\234"}, {(int) KS_CWS, "\033[203;%p1%d;%p2%d/y"}, {(int) KS_CWP, "\033[205;%p1%d;%p2%d/y"}, {K_UP, "\033[A"}, {K_DOWN, "\033[B"}, {K_LEFT, "\033[D"}, {K_RIGHT, "\033[C"}, {K_S_UP, "\033[161q"}, {K_S_DOWN, "\033[164q"}, {K_S_LEFT, "\033[158q"}, {K_S_RIGHT, "\033[167q"}, {K_F1, "\033[001q"}, {K_F2, "\033[002q"}, {K_F3, "\033[003q"}, {K_F4, "\033[004q"}, {K_F5, "\033[005q"}, {K_F6, "\033[006q"}, {K_F7, "\033[007q"}, {K_F8, "\033[008q"}, {K_F9, "\033[009q"}, {K_F10, "\033[010q"}, {K_F11, "\033[011q"}, {K_F12, "\033[012q"}, {K_S_F1, "\033[013q"}, {K_S_F2, "\033[014q"}, {K_S_F3, "\033[015q"}, {K_S_F4, "\033[016q"}, {K_S_F5, "\033[017q"}, {K_S_F6, "\033[018q"}, {K_S_F7, "\033[019q"}, {K_S_F8, "\033[020q"}, {K_S_F9, "\033[021q"}, {K_S_F10, "\033[022q"}, {K_S_F11, "\033[023q"}, {K_S_F12, "\033[024q"}, {K_INS, "\033[139q"}, {K_HOME, "\033[H"}, {K_END, "\033[146q"}, {K_PAGEUP, "\033[150q"}, {K_PAGEDOWN, "\033[154q"}, {(int) KS_NAME, "dumb"}, {(int) KS_CL, "\014"}, {(int) KS_CM, IF_EB ("\033[%i%p1%d;%p2%dH", ESC_STR "[%i%p1%d;%p2%dH")}, {(int) KS_NAME, NULL}};
int detected_8bit = FALSE;
gui_T gui;
EXTERN time_T starttime;
EXTERN FILE *time_fd INIT (= NULL);
mparm_T params;

int spell_check_GRAFT_INTERFACE (typval_T *$_host_rettv, typval_T *$_host_argvars, int $_host_capcol, int $_host_len, hlf_T $_host_attr, char_u *$_host_str, char_u *$_host_word) {
    char **$_main_argv;
    params.$_main_argv = $_main_argv;
    parse_command_name (& params);
    command_line_scan (& params);
    time_msg ("parsing arguments", NULL);
    if (recoverymode && params.fname == NULL) {
    }
    $_host_str = DEFAULT_TERM;
    struct builtin_term *$_set_termname_termp_1;
    for ($_set_termname_termp_1 = &(builtin_termcaps[0]); $_set_termname_termp_1->bt_string != NULL; ++$_set_termname_termp_1) {
    }
    if (!is_not_a_term ()) {
    }
    out_flush ();
    --$_host_capcol;
    clip_init (FALSE);
    set_string_option_direct ((char_u *) "mouse", - 1, (char_u *) "a", OPT_FREE, SID_NONE);
    --$_host_capcol;
LABEL_gui_mch_init1 :
    if (0) {
    }
LABEL_gui_init1 :
    if (0) {
    }
LABEL_set_termname1 :
    if (0) {
    }
LABEL_termcapinit1 :
    if (0) {
    }
    goto LABEL_main;
}

